# Assessment 1 Test Suite

###
# group: User / Get Empty Users
# @name Get All Users Empty
# Initially no users have been created so this method should return an empty array.
# Status Expected: success
# Expected Response: [ ] (an empty array)
GET localhost:8080/users

> {%
    // TODO: migrate to HTTP Client Response handler API
    // const userSchema = pm.environment.get('userSchema')
    //
    // const schema = {
    //     type: 'array',
    //     description: 'An array of user dto\'s',
    //     items: { $ref: userSchema }
    // }
    //
    // pm.test('Schema is valid', () => {
    //   pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true
    // })
    //
    // pm.test('Returns an empty array', () => {
    //     pm.expect(pm.response.json().length).to.eql(0)
    // })
%}

###
# group: User / Get Empty Users
# @name Get NonExisting User
# Attempts to get a user that doesn't exist in the database (at this point in testing). Should return an error code with no response body.
# Expected Status: error (400s && 500s) (Preferably a 404 Not Found!)
# Expected Body: none
GET localhost:8080/users/@doesNotExist

> {%
    // TODO: migrate to HTTP Client Response handler API
    // pm.test('Status error', () => {
    //     pm.response.to.not.be.success
    //     pm.response.to.not.be.info
    // })
    //
    // pm.test('Should not be an internal server error', () => {
    //     pm.response.to.not.be.serverError
    // })
%}

###
# group: User / Create New Users
# @name Create FirstUser Fail (No Email)
# If a user tries to create a user without a password, an error code of some kind should be sent in leu of a response.
# Expected Status: An "error" status code. Somewhere in the 400s or 500s.
# No Response Body expected. If the student adds more advanced error handling though, we should not penalize them.
POST localhost:8080/users
Content-Type: application/json

{
  "credentials": {
    "username": "{{firstUser}}",
    "password": "{{password}}"
  },
  "profile": {
    "firstName": "{{firstUserFirstName}}",
    "lastName": "{{firstUserLastName}}",
    "phone": "{{firstUserPhone}}"
  }
}

> {%
    // TODO: migrate to HTTP Client Response handler API
    // pm.test('Status not success (password required)', () => {
    //     pm.response.to.not.be.success
    //     pm.response.to.not.be.info
    // })
    //
    // pm.test('Should not be an internal server error', () => {
    //     pm.response.to.not.be.serverError
    // })
%}

###
# group: User / Create New Users
# @name Create FirstUser Fail (No Password)
# If a user tries to create a user without a password, an error code of some kind should be sent in leu of a response.
# Expected Status: An "error" status code. Somewhere in the 400s or 500s.
# No Response Body expected. If the student adds more advanced error handling though, we should not penalize them.
POST localhost:8080/users
Content-Type: application/json

{
  "credentials": {
    "username": "{{firstUser}}"
  },
  "profile": {
  	"email": "{{firstUserEmail}}",
    "firstName": "{{firstUserFirstName}}",
    "lastName": "{{firstUserLastName}}",
    "phone": "{{firstUserPhone}}"
  }
}

> {%
    // TODO: migrate to HTTP Client Response handler API
    // pm.test('Status not success (password required)', () => {
    //     pm.response.to.not.be.success
    //     pm.response.to.not.be.info
    // })
    //
    // pm.test('Should not be an internal server error', () => {
    //     pm.response.to.not.be.serverError
    // })
%}

###
# group: User / Create New Users
# @name Create FirstUser Fail (No Username)
# If a user tries to create a user without a username, an error code of some kind should be sent in leu of a response.
# Expected Status: An "error" status code. Somewhere in the 400s or 500s.
# No Response Body expected. If the student adds more advanced error handling though, we should not penalize them.
POST localhost:8080/users
Content-Type: application/json

{
  "credentials": {
    "password": "{{password}}"
  },
  "profile": {
  	"email": "{{firstUserEmail}}",
    "firstName": "{{firstUserFirstName}}",
    "lastName": "{{firstUserLastName}}",
    "phone": "{{firstUserPhone}}"
  }
}

> {%
    // TODO: migrate to HTTP Client Response handler API
    // pm.test('Status not success (username required)', () => {
    //     pm.response.to.not.be.success
    //     pm.response.to.not.be.info
    // })
    //
    // pm.test('Should not be an internal server error', () => {
    //     pm.response.to.not.be.serverError
    // })
%}

###
# group: User / Create New Users
# @name Create FirstUser
# If a user tries to create a user without a username, an error code of some kind should be sent in leu of a response.
# Expected Status: An "error" status code. Somewhere in the 400s or 500s.
# No Response Body expected. If the student adds more advanced error handling though, we should not penalize them.
POST localhost:8080/users
Content-Type: application/json

{
  "credentials": {
  	"username": "{{firstUser}}",
    "password": "{{password}}"
  },
  "profile": {
    "email": "{{firstUserEmail}}",
    "firstName": "{{firstUserFirstName}}",
    "lastName": "{{firstUserLastName}}",
    "phone": "{{firstUserPhone}}"
  }
}

> {%
    // TODO: migrate to HTTP Client Response handler API
    // const schema = pm.environment.get('userSchema')
    //
    // if (pm.response.code >= 200 && pm.response.code < 300) {
    //     pm.test('Success status', () => {
    //         pm.response.to.be.success
    //     })
    //     
    //     pm.test('Schema is valid', () => {
    //       pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true
    //     })
    //     
    //     pm.test('Username was set correctly', () => {
    //         pm.expect(pm.response.json().username).to.eql(pm.environment.get('firstUser'))
    //     })
    //     
    //     pm.test('Joined date was set', () => {
    //         const joined = pm.response.json().joined
    //         pm.expect(joined).to.not.eql(null)
    //         pm.expect(joined).to.not.eql(undefined)
    //         pm.environment.set('firstUserJoined', joined)
    //     })
    //     
    //     pm.test('Profile was set correctly', () => {
    //         const profile = pm.response.json().profile
    //         pm.expect(profile.firstName).to.eql(pm.environment.get('firstUserFirstName'))
    //         pm.expect(profile.lastName).to.eql(pm.environment.get('firstUserLastName'))
    //         pm.expect(profile.email).to.eql(pm.environment.get('firstUserEmail'))
    //         pm.expect(profile.phone).to.eql(pm.environment.get('firstUserPhone'))
    //     })
    // } else {
    //     pm.test('Error status', () => {
    //         pm.response.to.not.be.info
    //         pm.response.to.not.be.success
    //     })
    //     
    //     pm.test('Should not be internal server error', () => {
    //         pm.response.to.not.be.serverError
    //     })
    //
    // }
%}

###
# group: User / Create New Users
# @name Create FirstUser Again
# If a user tries to create a user without a username, an error code of some kind should be sent in leu of a response.
# Expected Status: An "error" status code. Somewhere in the 400s or 500s.
# No Response Body expected. If the student adds more advanced error handling though, we should not penalize them.
POST localhost:8080/users
Content-Type: application/json

{
  "credentials": {
    "username": "{{firstUser}}",
    "password": "{{password}}"
  },
  "profile": {
    "email": "{{firstUserEmail}}",
    "firstName": "{{firstUserFirstName}}",
    "lastName": "{{firstUserLastName}}",
    "phone": "{{firstUserPhone}}"
  }
}

> {%
    // TODO: migrate to HTTP Client Response handler API
    // pm.test('Error status', () => {
    //     pm.response.to.not.be.info
    //     pm.response.to.not.be.success
    // })
    //
    // pm.test('Should not be internal server error', () => {
    //     pm.response.to.not.be.serverError
    // })
%}

###
# group: User / Create New Users
# @name Create SecondUser Fail (No Credentials)
# If a user tries to create a user without any credentials, an error code of some kind should be sent in leu of a response.
# Expected Status: An "error" status code. Somewhere in the 400s or 500s.
# No Response Body expected. If the student adds more advanced error handling though, we should not penalize them.
POST localhost:8080/users
Content-Type: application/json

{
  "profile": {
    "email": "{{secondUserEmail}}"
  }
}

> {%
    // TODO: migrate to HTTP Client Response handler API
    // pm.test('Status not success (credentials required)', () => {
    //     pm.response.to.not.be.success
    //     pm.response.to.not.be.info
    // })
    //
    // pm.test('Should not be an internal server error', () => {
    //     pm.response.to.not.be.serverError
    // })
%}

###
# group: User / Create New Users
# @name Create SecondUser Fail (Empty Request)
# If a user tries to create a user with an empty request, an error code of some kind should be sent in leu of a response.
# Expected Status: An "error" status code. Somewhere in the 400s or 500s.
# No Response Body expected. If the student adds more advanced error handling though, we should not penalize them.
POST localhost:8080/users
Content-Type: application/json

{
}

> {%
    // TODO: migrate to HTTP Client Response handler API
    // pm.test('Status not success (request is empty)', () => {
    //     pm.response.to.not.be.success
    //     pm.response.to.not.be.info
    // })
    //
    // pm.test('Should not be an internal server error', () => {
    //     pm.response.to.not.be.serverError
    // })
%}

###
# group: User / Create New Users
# @name Create SecondUser Fail (No Profile)
# If a user tries to create a user with no profile at all, an error code of some kind should be sent in leu of a response.
# Expected Status: An "error" status code. Somewhere in the 400s or 500s.
# No Response Body expected. If the student adds more advanced error handling though, we should not penalize them.
POST localhost:8080/users
Content-Type: application/json

{
  "credentials": {
    "username": "{{secondUser}}",
    "password": "{{password}}"
  }
}

> {%
    // TODO: migrate to HTTP Client Response handler API
    // pm.test('Status not success (password required)', () => {
    //     pm.response.to.not.be.success
    //     pm.response.to.not.be.info
    // })
    //
    // pm.test('Should not be an internal server error', () => {
    //     pm.response.to.not.be.serverError
    // })
%}

###
# group: User / Create New Users
# @name Create SecondUser
# If a user tries to create a user with an empty request, an error code of some kind should be sent in leu of a response.
# Expected Status: An "error" status code. Somewhere in the 400s or 500s.
# No Response Body expected. If the student adds more advanced error handling though, we should not penalize them.
POST localhost:8080/users
Content-Type: application/json

{
  "credentials": {
  	"username": "{{secondUser}}",
  	"password": "{{password}}"
  },
  "profile": {
    "firstName": "{{secondUserFirstName}}",
    "lastName": "{{secondUserLastName}}",
    "email": "{{secondUserEmail}}",
    "phone": "{{secondUserPhone}}"
  }
}

> {%
    // TODO: migrate to HTTP Client Response handler API
    // const schema = pm.environment.get('userSchema')
    //
    // pm.test('Success status', () => {
    //     pm.response.to.be.success
    // })
    //
    // pm.test('Schema is valid', () => {
    //   pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true
    // })
    //
    // pm.test('Username was set correctly', () => {
    //     pm.expect(pm.response.json().username).to.eql(pm.environment.get('secondUser'))
    // })
    //
    // pm.test('Joined date was set', () => {
    //     const joined = pm.response.json().joined
    //     pm.expect(joined).to.not.eql(null)
    //     pm.expect(joined).to.not.eql(undefined)
    //     pm.environment.set('secondUserJoined', joined)
    // })
    //
    // pm.test('Profile was set correctly', () => {
    //     const profile = pm.response.json().profile
    //     pm.expect(profile.firstName).to.eql(pm.environment.get('secondUserFirstName'))
    //     pm.expect(profile.lastName).to.eql(pm.environment.get('secondUserLastName'))
    //     pm.expect(profile.email).to.eql(pm.environment.get('secondUserEmail'))
    //     pm.expect(profile.phone).to.eql(pm.environment.get('secondUserPhone'))
    // })
%}

###
# group: User / Create New Users
# @name Create SecondUser Again
# If a user tries to create a user with an empty request, an error code of some kind should be sent in leu of a response.
# Expected Status: An "error" status code. Somewhere in the 400s or 500s.
# No Response Body expected. If the student adds more advanced error handling though, we should not penalize them.
POST localhost:8080/users
Content-Type: application/json

{
  "credentials": {
    "username": "{{secondUser}}",
    "password": "{{password}}"
  },
  "profile": {
    "email": "{{secondUserEmail}}"
  }
}

> {%
    // TODO: migrate to HTTP Client Response handler API
    // pm.test('Error status', () => {
    //     pm.response.to.not.be.info
    //     pm.response.to.not.be.success
    // })
    //
    // pm.test('Should not be internal server error', () => {
    //     pm.response.to.not.be.serverError
    // })
%}

###
# group: User / Update User
# @name Update NonExisting User
# Attempts to update a user that does not exist (at least at this point in testing). Should return an error with no response body.
# Expected Status: error
# Expected Body: none
PATCH localhost:8080/users/@nonExisting
Content-Type: application/json

{
  "credentials": {
    "username": "doesn't matter",
    "password": "probably shouldn't be one"
  },
  "profile": {
    "email": "test@test.com",
    "firstName": "filling this in for funzies",
    "lastName": "literally doesn't matter",
    "phone": "not going to work!"
  }
}

> {%
    // TODO: migrate to HTTP Client Response handler API
    // pm.test('Status error', () => {
    //     pm.response.to.not.be.success
    //     pm.response.to.not.be.info
    // })
    //
    // pm.test('Should not be an internal server error', () => {
    //     pm.response.to.not.be.serverError
    // })
%}

###
# group: User / Update User
# @name Update SecondUser Fail (No Username)
# Attempts to update the secondUser with no username provided. Should return an error and no body.
# Expected Status: error
# Expected Body: none
PATCH localhost:8080/users/@{{secondUser}}
Content-Type: application/json

{
  "credentials": {
    "password": "{{password}}"
  },
  "profile": {
    "email": "{{secondUserEmail}}",
    "firstName": "{{secondUserFirstName}}",
    "lastName": "{{secondUserLastName}}",
    "phone": "{{secondUserPhone}}"
  }
}

> {%
    // TODO: migrate to HTTP Client Response handler API
    // pm.test('Status error', () => {
    //     pm.response.to.not.be.success
    //     pm.response.to.not.be.info
    // })
    //
    // pm.test('Should not be an internal server error', () => {
    //     pm.response.to.not.be.serverError
    // })
%}

###
# group: User / Update User
# @name Update SecondUser Fail (No Password)
# Attempts to update the secondUser with no password provided. Should return an error and no body.
# Expected Status: error
# Expected Body: none
PATCH localhost:8080/users/@{{secondUser}}
Content-Type: application/json

{
  "credentials": {
  	"username": "{{secondUser}}"
  },
  "profile": {
    "email": "{{secondUserEmail}}",
    "firstName": "{{secondUserFirstName}}",
    "lastName": "{{secondUserLastName}}",
    "phone": "{{secondUserPhone}}"
  }
}

> {%
    // TODO: migrate to HTTP Client Response handler API
    // pm.test('Status error', () => {
    //     pm.response.to.not.be.success
    //     pm.response.to.not.be.info
    // })
    //
    // pm.test('Should not be an internal server error', () => {
    //     pm.response.to.not.be.serverError
    // })
%}

###
# group: User / Update User
# @name Update SecondUser Fail (No Credentials)
# Updates the profile of a user with the given username. If no such user exists, the user is deleted, or the provided credentials do not match the user, an error should be sent in lieu of a response. In the case of a successful update, the returned user should contain the updated data.
# Request:
# {
#   "credentials": {
#     "username": "{username}",
#     "password": "{password}"
#   },
#   "profile": {
#     "firstName": "{firstName}",
#     "lastName": "{lastName}",
#     "email": "{email}",
#     "phone": "{phoneNumber}"
#   }
# }
# Response:
# {
#     "username": "{username}",
#     "joined": {joinedDate},
#     "profile": {
#         "firstName": "{firstName}",
#         "lastName": "{lastName}",
#         "email": "{email}",
#         "phone": "{phoneNumber}"
#     }
# }
PATCH localhost:8080/users/@{{secondUser}}
Content-Type: application/json

{
  "profile": {
    "email": "{{secondUserEmail}}",
    "firstName": "{{secondUserFirstName}}",
    "lastName": "{{secondUserLastName}}",
    "phone": "{{secondUserPhone}}"
  }
}

> {%
    // TODO: migrate to HTTP Client Response handler API
    // pm.test('Status error', () => {
    //     pm.response.to.not.be.success
    //     pm.response.to.not.be.info
    // })
    //
    // pm.test('Should not be an internal server error', () => {
    //     pm.response.to.not.be.serverError
    // })
%}

###
# group: User / Update User
# @name Update SecondUser Fail (No Profile)
# Updates the profile of a user with the given username. If no such user exists, the user is deleted, or the provided credentials do not match the user, an error should be sent in lieu of a response. In the case of a successful update, the returned user should contain the updated data.
# Request:
# {
#   "credentials": {
#     "username": "{username}",
#     "password": "{password}"
#   },
#   "profile": {
#     "firstName": "{firstName}",
#     "lastName": "{lastName}",
#     "email": "{email}",
#     "phone": "{phoneNumber}"
#   }
# }
# Response:
# {
#     "username": "{username}",
#     "joined": {joinedDate},
#     "profile": {
#         "firstName": "{firstName}",
#         "lastName": "{lastName}",
#         "email": "{email}",
#         "phone": "{phoneNumber}"
#     }
# }
PATCH localhost:8080/users/@{{secondUser}}
Content-Type: application/json

{
  "credentials": {
    "username": "{{secondUser}}",
    "password": "{{password}}"
  }
}

> {%
    // TODO: migrate to HTTP Client Response handler API
    // pm.test('Status error', () => {
    //     pm.response.to.not.be.success
    //     pm.response.to.not.be.info
    // })
    //
    // pm.test('Should not be an internal server error', () => {
    //     pm.response.to.not.be.serverError
    // })
%}

###
# group: User / Update User
# @name Update SecondUser First Empty
# Updates the profile of a user with the given username. If no such user exists, the user is deleted, or the provided credentials do not match the user, an error should be sent in lieu of a response. In the case of a successful update, the returned user should contain the updated data.
# Request:
# {
#   "credentials": {
#     "username": "{username}",
#     "password": "{password}"
#   },
#   "profile": {
#     "firstName": "{firstName}",
#     "lastName": "{lastName}",
#     "email": "{email}",
#     "phone": "{phoneNumber}"
#   }
# }
# Response:
# {
#     "username": "{username}",
#     "joined": {joinedDate},
#     "profile": {
#         "firstName": "{firstName}",
#         "lastName": "{lastName}",
#         "email": "{email}",
#         "phone": "{phoneNumber}"
#     }
# }
PATCH localhost:8080/users/@{{secondUser}}
Content-Type: application/json

{
  "credentials": {
    "username": "{{secondUser}}",
    "password": "{{password}}"
  },
  "profile": {
  }
}

> {%
    // TODO: migrate to HTTP Client Response handler API
    // const schema = pm.environment.get('userSchema')
    //
    // pm.test('Status success', () => {
    //     pm.response.to.be.success
    // })
    //
    // pm.test('Schema is valid', () => {
    //   pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true
    // })
    //
    // pm.test('Username matches', () => {
    //     pm.expect(pm.response.json().username).to.eql(pm.environment.get('secondUser'))
    // })
    //
    // pm.test('Joined date has not been modified', () => {
    //     pm.expect(new Date(pm.response.json().joined)).to.eql(new Date(pm.environment.get('secondUserJoined')))
    // })
    //
    //
    // pm.test('Profile was set correctly', () => {
    //     const profile = pm.response.json().profile
    //     pm.expect(profile.firstName).to.eql(pm.environment.get('secondUserFirstName'))
    //     pm.expect(profile.lastName).to.eql(pm.environment.get('secondUserLastName'))
    //     pm.expect(profile.email).to.eql(pm.environment.get('secondUserEmail'))
    //     pm.expect(profile.phone).to.eql(pm.environment.get('secondUserPhone'))
    // })
%}

###
# group: User / Update User
# @name Update SecondUser
# Updates the profile of a user with the given username. If no such user exists, the user is deleted, or the provided credentials do not match the user, an error should be sent in lieu of a response. In the case of a successful update, the returned user should contain the updated data.
# Request:
# {
#   "credentials": {
#     "username": "{username}",
#     "password": "{password}"
#   },
#   "profile": {
#     "firstName": "{firstName}",
#     "lastName": "{lastName}",
#     "email": "{email}",
#     "phone": "{phoneNumber}"
#   }
# }
# Response:
# {
#     "username": "{username}",
#     "joined": {joinedDate},
#     "profile": {
#         "firstName": "{firstName}",
#         "lastName": "{lastName}",
#         "email": "{email}",
#         "phone": "{phoneNumber}"
#     }
# }
PATCH localhost:8080/users/@{{secondUser}}
Content-Type: application/json

{
  "credentials": {
    "username": "{{secondUser}}",
    "password": "{{password}}"
  },
  "profile": {
    "email": "{{secondUserEmail}}",
    "firstName": "{{secondUserFirstName}}",
    "lastName": "{{secondUserLastName}}",
    "phone": "{{secondUserPhone}}"
  }
}

> {%
    // TODO: migrate to HTTP Client Response handler API
    // const schema = pm.environment.get('userSchema')
    //
    // pm.test('Status success', () => {
    //     pm.response.to.be.success
    // })
    //
    // pm.test('Schema is valid', () => {
    //   pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true
    // })
    //
    // pm.test('Username matches', () => {
    //     pm.expect(pm.response.json().username).to.eql(pm.environment.get('secondUser'))
    // })
    //
    // pm.test('Joined date has not been modified', () => {
    //     pm.expect(new Date(pm.response.json().joined)).to.eql(new Date(pm.environment.get('secondUserJoined')))
    // })
    //
    // pm.test('Profile is correct', () => {
    //     const profile = pm.response.json().profile
    //     pm.expect(profile.firstName).to.eql(pm.environment.get('secondUserFirstName'))
    //     pm.expect(profile.lastName).to.eql(pm.environment.get('secondUserLastName'))
    //     pm.expect(profile.email).to.eql(pm.environment.get('secondUserEmail'))
    //     pm.expect(profile.phone).to.eql(pm.environment.get('secondUserPhone'))
    // })
%}

###
# group: User / Update User
# @name Update SecondUser Second Empty
# Updates the profile of a user with the given username. If no such user exists, the user is deleted, or the provided credentials do not match the user, an error should be sent in lieu of a response. In the case of a successful update, the returned user should contain the updated data.
# Request:
# {
#   "credentials": {
#     "username": "{username}",
#     "password": "{password}"
#   },
#   "profile": {
#     "firstName": "{firstName}",
#     "lastName": "{lastName}",
#     "email": "{email}",
#     "phone": "{phoneNumber}"
#   }
# }
# Response:
# {
#     "username": "{username}",
#     "joined": {joinedDate},
#     "profile": {
#         "firstName": "{firstName}",
#         "lastName": "{lastName}",
#         "email": "{email}",
#         "phone": "{phoneNumber}"
#     }
# }
PATCH localhost:8080/users/@{{secondUser}}
Content-Type: application/json

{
  "credentials": {
    "username": "{{secondUser}}",
    "password": "{{password}}"
  },
  "profile": {
  }
}

> {%
    // TODO: migrate to HTTP Client Response handler API
    // const schema = pm.environment.get('userSchema')
    //
    // pm.test('Status success', () => {
    //     pm.response.to.be.success
    // })
    //
    // pm.test('Schema is valid', () => {
    //   pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true
    // })
    //
    // pm.test('Username matches', () => {
    //     pm.expect(pm.response.json().username).to.eql(pm.environment.get('secondUser'))
    // })
    //
    // pm.test('Joined date has not been modified', () => {
    //     pm.expect(new Date(pm.response.json().joined)).to.eql(new Date(pm.environment.get('secondUserJoined')))
    // })
    //
    //
    // pm.test('Profile was set correctly', () => {
    //     const profile = pm.response.json().profile
    //     pm.expect(profile.firstName).to.eql(pm.environment.get('secondUserFirstName'))
    //     pm.expect(profile.lastName).to.eql(pm.environment.get('secondUserLastName'))
    //     pm.expect(profile.email).to.eql(pm.environment.get('secondUserEmail'))
    //     pm.expect(profile.phone).to.eql(pm.environment.get('secondUserPhone'))
    // })
%}

###
# group: User / Get Existing Users
# @name Get All Users
# Initially no users have been created so this method should return an empty array.
# Status Expected: success
# Expected Response: [ ] (an empty array)
GET localhost:8080/users

> {%
    // TODO: migrate to HTTP Client Response handler API
    // const userSchema = pm.environment.get('userSchema')
    //
    // const schema = {
    //     'type': 'array',
    //     'description': 'An array of user dto\'s',
    //     'items': { $ref: userSchema }
    // }
    //
    // pm.test('Status success', () => {
    //     pm.response.to.be.success
    // })
    //
    // pm.test('Schema is valid', () => {
    //   pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true
    // })
    //
    // pm.test('Returns an array with two users', () => {
    //     pm.expect(pm.response.json().length).to.eql(2)
    // })
    //
    // if (pm.response.json() !== null && Array.isArray(pm.response.json())) {
    //     const users = pm.response.json().map(user => user.username)
    //     
    //     pm.test('Contains the firstUser', () => {
    //         pm.expect(users).to.include(pm.environment.get('firstUser'))
    //     })
    //     
    //     pm.test('Contains the secondUser', () => {
    //         pm.expect(users).to.include(pm.environment.get('secondUser'))
    //     })
    // }
    //
    //
%}

###
# group: User / Get Existing Users
# @name Get FirstUser
# Initially no users have been created so this method should return an empty array.
# Status Expected: success
# Expected Response: [ ] (an empty array)
GET localhost:8080/users/@{{firstUser}}

> {%
    // TODO: migrate to HTTP Client Response handler API
    // const schema = pm.environment.get('userSchema')
    //
    // pm.test('Status success', () => {
    //     pm.response.to.be.success
    // })
    //
    // pm.test('Schema is valid', () => {
    //   pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true
    // })
    //
    // pm.test('Username is correct', () => {
    //     pm.expect(pm.response.json().username).to.eql(pm.environment.get('firstUser'))
    // })
    //
    // pm.test('Joined has not been modified', () => {
    //     pm.expect(new Date(pm.response.json().joined)).to.eql(new Date(pm.environment.get('firstUserJoined')))
    // })
    //
    // pm.test('Profile is correct', () => {
    //     const profile = pm.response.json().profile
    //     pm.expect(profile.firstName).to.eql(pm.environment.get('firstUserFirstName'))
    //     pm.expect(profile.lastName).to.eql(pm.environment.get('firstUserLastName'))
    //     pm.expect(profile.email).to.eql(pm.environment.get('firstUserEmail'))
    //     pm.expect(profile.phone).to.eql(pm.environment.get('firstUserPhone'))
    // })
%}

###
# group: User / Get Existing Users
# @name Get SecondUser
# Initially no users have been created so this method should return an empty array.
# Status Expected: success
# Expected Response: [ ] (an empty array)
GET localhost:8080/users/@{{secondUser}}

> {%
    // TODO: migrate to HTTP Client Response handler API
    // const schema = pm.environment.get('userSchema')
    //
    // pm.test('Status success', () => {
    //     pm.response.to.be.success
    // })
    //
    // pm.test('Schema is valid', () => {
    //   pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true
    // })
    //
    // pm.test('Username is correct', () => {
    //     pm.expect(pm.response.json().username).to.eql(pm.environment.get('secondUser'))
    // })
    //
    // pm.test('Joined has not been modified', () => {
    //     pm.expect(new Date(pm.response.json().joined)).to.eql(new Date(pm.environment.get('secondUserJoined')))
    // })
    //
    // pm.test('Profile is correct', () => {
    //     const profile = pm.response.json().profile
    //     pm.expect(profile.firstName).to.eql(pm.environment.get('secondUserFirstName'))
    //     pm.expect(profile.lastName).to.eql(pm.environment.get('secondUserLastName'))
    //     pm.expect(profile.email).to.eql(pm.environment.get('secondUserEmail'))
    //     pm.expect(profile.phone).to.eql(pm.environment.get('secondUserPhone'))
    // })
%}

###
# group: User / Follow and Unfollow
# @name Get Random Followers
# Retrieves the followers of the user with the given username. Only active users should be included in the response. If no active user with the given username exists, an error should be sent in lieu of a response.
# #### Response
# ```
# [ // Array of Users
# 	{
# 		"username": "string",
# 		"profile": {
# 			"firstName"?: "string",
# 			"lastName"?: "string",
# 			"email": "string",
# 			"phone"?: "string"
# 		},
# 		"joined": timestamp
# 	}
# ]
# ```
# * Remember that question marks denote optional values.
GET localhost:8080/users/@random/followers

> {%
    // TODO: migrate to HTTP Client Response handler API
    // pm.test('Status not success', () => {
    //     pm.response.to.not.be.success
    //     pm.response.to.not.be.info
    // })
    //
    // pm.test('Status should not be internal server error', () => {
    //     pm.response.to.not.be.serverError
    // })
%}

###
# group: User / Follow and Unfollow
# @name Get Random Following
# Retrieves the followers of the user with the given username. Only active users should be included in the response. If no active user with the given username exists, an error should be sent in lieu of a response.
# #### Response
# ```
# [ // Array of Users
# 	{
# 		"username": "string",
# 		"profile": {
# 			"firstName"?: "string",
# 			"lastName"?: "string",
# 			"email": "string",
# 			"phone"?: "string"
# 		},
# 		"joined": timestamp
# 	}
# ]
# ```
# * Remember that question marks denote optional values.
GET localhost:8080/users/@random/following

> {%
    // TODO: migrate to HTTP Client Response handler API
    // pm.test('Status not success', () => {
    //     pm.response.to.not.be.success
    //     pm.response.to.not.be.info
    // })
    //
    // pm.test('Status should not be internal server error', () => {
    //     pm.response.to.not.be.serverError
    // })
%}

###
# group: User / Follow and Unfollow
# @name FirstUser Follow SecondUser Fail (No Credentials)
# Attempts to follow the secondUser without providing the credentials of the firstUser. Should return an error status and no body.
# Expected Status: error
# Expected Body: none
POST localhost:8080/users/@{{secondUser}}/follow
Content-Type: application/json

{}

> {%
    // TODO: migrate to HTTP Client Response handler API
    // pm.test('Status not success', () => {
    //     pm.response.to.not.be.success
    //     pm.response.to.not.be.info
    // })
    //
    // pm.test('Should not be an internal server error', () => {
    //     pm.response.to.not.be.serverError
    // })
%}

###
# group: User / Follow and Unfollow
# @name FirstUser Follow SecondUser Fail (No Password)
# Attempts to follow the secondUser without providing the password of the firstUser. Should return an error status and no body.
# Expected Status: error
# Expected Body: none
POST localhost:8080/users/@{{secondUser}}/follow
Content-Type: application/json

{
  "username": "{{firstUser}}"
}

> {%
    // TODO: migrate to HTTP Client Response handler API
    // pm.test('Status not success', () => {
    //     pm.response.to.not.be.success
    //     pm.response.to.not.be.info
    // })
    //
    // pm.test('Should not be an internal server error', () => {
    //     pm.response.to.not.be.serverError
    // })
%}

###
# group: User / Follow and Unfollow
# @name FirstUser Follow SecondUser Fail (No Username)
# Attempts to follow the secondUser without providing the username of the firstUser. Should return an error status and no body.
# Expected Status: error
# Expected Body: none
POST localhost:8080/users/@{{secondUser}}/follow
Content-Type: application/json

{
  "password": "{{password}}"
}

> {%
    // TODO: migrate to HTTP Client Response handler API
    // pm.test('Status not success', () => {
    //     pm.response.to.not.be.success
    //     pm.response.to.not.be.info
    // })
    //
    // pm.test('Should not be an internal server error', () => {
    //     pm.response.to.not.be.serverError
    // })
%}

###
# group: User / Follow and Unfollow
# @name FirstUser Follow SecondUser
# Attempts to follow the secondUser without providing the username of the firstUser. Should return an error status and no body.
# Expected Status: error
# Expected Body: none
POST localhost:8080/users/@{{secondUser}}/follow
Content-Type: application/json

{
  "username": "{{firstUser}}",
  "password": "{{password}}"
}

> {%
    // TODO: migrate to HTTP Client Response handler API
    // pm.test('Should be success', () => {
    //     pm.response.to.be.success
    // })
    //
%}

###
# group: User / Follow and Unfollow
# @name FirstUser Follow SecondUser Again
# Attempts to follow the secondUser without providing the username of the firstUser. Should return an error status and no body.
# Expected Status: error
# Expected Body: none
POST localhost:8080/users/@{{secondUser}}/follow
Content-Type: application/json

{
  "credentials": {
	  "username": "{{firstUser}}",
	  "password": "{{password}}"
  }
}

> {%
    // TODO: migrate to HTTP Client Response handler API
    // pm.test('Status error', () => {
    //     pm.response.to.not.be.success
    // })
    //
    // pm.test('Should not be internal server error', () => {
    //     pm.response.to.not.be.serverError
    // })
%}

###
# group: User / Follow and Unfollow
# @name Get SecondUser Followers
# Retrieves the followers of the user with the given username. Only active users should be included in the response. If no active user with the given username exists, an error should be sent in lieu of a response.
# #### Response
# ```
# [ // Array of Users
# 	{
# 		"username": "string",
# 		"profile": {
# 			"firstName"?: "string",
# 			"lastName"?: "string",
# 			"email": "string",
# 			"phone"?: "string"
# 		},
# 		"joined": timestamp
# 	}
# ]
# ```
# * Remember that question marks denote optional values.
GET localhost:8080/users/@{{secondUser}}/followers

> {%
    // TODO: migrate to HTTP Client Response handler API
    // const userSchema = pm.environment.get('userSchema')
    //
    // const schema = {
    //     'type': 'array',
    //     'description': 'An array of user dto\'s',
    //     'items': { $ref: userSchema }
    // }
    //
    // pm.test('Status success', () => {
    //     pm.response.to.be.success
    // })
    //
    // pm.test('Schema is valid', () => {
    //   pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true
    // })
    //
    // pm.test('Array contains only 1 user', () => {
    //     pm.expect(pm.response.json().length).to.eql(1)
    // })
    //
    // if (pm.response.code === 200 && pm.response.json() !== null && Array.isArray(pm.response.json())) {
    //     const users = pm.response.json().map(user => user.username)
    //     
    //     pm.test('Contains the firstUser', () => {
    //         pm.expect(users).to.include(pm.environment.get('firstUser'))
    //     })
    // }
%}

###
# group: User / Follow and Unfollow
# @name Get FirstUser Following
# Retrieves the followers of the user with the given username. Only active users should be included in the response. If no active user with the given username exists, an error should be sent in lieu of a response.
# #### Response
# ```
# [ // Array of Users
# 	{
# 		"username": "string",
# 		"profile": {
# 			"firstName"?: "string",
# 			"lastName"?: "string",
# 			"email": "string",
# 			"phone"?: "string"
# 		},
# 		"joined": timestamp
# 	}
# ]
# ```
# * Remember that question marks denote optional values.
GET localhost:8080/users/@{{firstUser}}/following

> {%
    // TODO: migrate to HTTP Client Response handler API
    // const userSchema = pm.environment.get('userSchema')
    //
    // const schema = {
    //     'type': 'array',
    //     'description': 'An array of user dto\'s',
    //     'items': { $ref: userSchema }
    // }
    //
    // pm.test('Status success', () => {
    //     pm.response.to.be.success
    // })
    //
    // pm.test('Schema is valid', () => {
    //   pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true
    // })
    //
    // pm.test('Array contains only 1 user', () => {
    //     pm.expect(pm.response.json().length).to.eql(1)
    // })
    //
    // if (pm.response.code === 200 && pm.response.json() !== null && Array.isArray(pm.response.json())) {
    //     const users = pm.response.json().map(user => user.username)
    //     
    //     pm.test('Contains the secondUser', () => {
    //         pm.expect(users).to.include(pm.environment.get('secondUser'))
    //     })
    // }
%}

###
# group: User / Follow and Unfollow
# @name SecondUser Follow FirstUser
# Attempts to follow the secondUser without providing the username of the firstUser. Should return an error status and no body.
# Expected Status: error
# Expected Body: none
POST localhost:8080/users/@{{firstUser}}/follow
Content-Type: application/json

{
  "username": "{{secondUser}}",
  "password": "{{password}}"
}

> {%
    // TODO: migrate to HTTP Client Response handler API
    // pm.test('Should be success', () => {
    //     pm.response.to.be.success
    // })
%}

###
# group: User / Follow and Unfollow
# @name SecondUser Follow FirstUser Again
# Attempts to follow the secondUser without providing the username of the firstUser. Should return an error status and no body.
# Expected Status: error
# Expected Body: none
POST localhost:8080/users/@{{firstUser}}/follow
Content-Type: application/json

{
  "credentials": {
	  "username": "{{secondUser}}",
	  "password": "{{password}}"
  }
}

> {%
    // TODO: migrate to HTTP Client Response handler API
    // pm.test('Status error', () => {
    //     pm.response.to.not.be.success
    // })
    //
    // pm.test('Should not be internal server error', () => {
    //     pm.response.to.not.be.serverError
    // })
%}

###
# group: User / Follow and Unfollow
# @name Get FirstUser Followers
# Retrieves the followers of the user with the given username. Only active users should be included in the response. If no active user with the given username exists, an error should be sent in lieu of a response.
# #### Response
# ```
# [ // Array of Users
# 	{
# 		"username": "string",
# 		"profile": {
# 			"firstName"?: "string",
# 			"lastName"?: "string",
# 			"email": "string",
# 			"phone"?: "string"
# 		},
# 		"joined": timestamp
# 	}
# ]
# ```
# * Remember that question marks denote optional values.
GET localhost:8080/users/@{{firstUser}}/followers

> {%
    // TODO: migrate to HTTP Client Response handler API
    // const userSchema = pm.environment.get('userSchema')
    //
    // const schema = {
    //     'type': 'array',
    //     'description': 'An array of user dto\'s',
    //     'items': { $ref: userSchema }
    // }
    //
    // pm.test('Status success', () => {
    //     pm.response.to.be.success
    // })
    //
    // pm.test('Schema is valid', () => {
    //   pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true
    // })
    //
    // pm.test('Array contains only 1 user', () => {
    //     pm.expect(pm.response.json().length).to.eql(1)
    // })
    //
    // if (pm.response.code === 200 && pm.response.json() !== null && Array.isArray(pm.response.json())) {
    //     const users = pm.response.json().map(user => user.username)
    //     
    //     pm.test('Contains the secondUser', () => {
    //         pm.expect(users).to.include(pm.environment.get('secondUser'))
    //     })
    // }
%}

###
# group: User / Follow and Unfollow
# @name Get SecondUser Following
# Retrieves the followers of the user with the given username. Only active users should be included in the response. If no active user with the given username exists, an error should be sent in lieu of a response.
# #### Response
# ```
# [ // Array of Users
# 	{
# 		"username": "string",
# 		"profile": {
# 			"firstName"?: "string",
# 			"lastName"?: "string",
# 			"email": "string",
# 			"phone"?: "string"
# 		},
# 		"joined": timestamp
# 	}
# ]
# ```
# * Remember that question marks denote optional values.
GET localhost:8080/users/@{{secondUser}}/following

> {%
    // TODO: migrate to HTTP Client Response handler API
    // const userSchema = pm.environment.get('userSchema')
    //
    // const schema = {
    //     'type': 'array',
    //     'description': 'An array of user dto\'s',
    //     'items': { $ref: userSchema }
    // }
    //
    // pm.test('Status success', () => {
    //     pm.response.to.be.success
    // })
    //
    // pm.test('Schema is valid', () => {
    //   pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true
    // })
    //
    // pm.test('Array contains only 1 user', () => {
    //     pm.expect(pm.response.json().length).to.eql(1)
    // })
    //
    // pm.test('Contains the firstUser', () => {
    //     const users = pm.response.json().map(user => user.username)
    //     pm.expect(users).to.include(pm.environment.get('firstUser'))
    // })
%}

###
# group: User / Follow and Unfollow
# @name SecondUser Unfollow DoesNotExist
# Attempts to unfollow a non-existent user. Should return an error status and no body.
# Expected Status: error
# Expected Body: none
POST localhost:8080/users/@doesNotExist/unfollow
Content-Type: application/json

{
  "username": "{{secondUser}}",
  "password": "{{password}}"
}

> {%
    // TODO: migrate to HTTP Client Response handler API
    // pm.test('Status not success', () => {
    //     pm.response.to.not.be.success
    //     pm.response.to.not.be.info
    // })
    //
    // pm.test('Should not be an internal server error', () => {
    //     pm.response.to.not.be.serverError
    // })
%}

###
# group: User / Follow and Unfollow
# @name SecondUser Unfollow FirstUser Fail (No Credentials)
# Attempts to unfollow the firstUser without providing the credentials of the secondUser. Should return an error status and no body.
# Expected Status: error
# Expected Body: none
POST localhost:8080/users/@{{firstUser}}/unfollow
Content-Type: application/json

{}

> {%
    // TODO: migrate to HTTP Client Response handler API
    // pm.test('Status not success', () => {
    //     pm.response.to.not.be.success
    //     pm.response.to.not.be.info
    // })
    //
    // pm.test('Should not be an internal server error', () => {
    //     pm.response.to.not.be.serverError
    // })
%}

###
# group: User / Follow and Unfollow
# @name SecondUser Unfollow FirstUser Fail (No Password)
# Attempts to unfollow the firstUser without providing the password of the secondUser. Should return an error status and no body.
# Expected Status: error
# Expected Body: none
POST localhost:8080/users/@{{firstUser}}/unfollow
Content-Type: application/json

{
  "username": "{{secondUser}}"
}

> {%
    // TODO: migrate to HTTP Client Response handler API
    // pm.test('Status not success', () => {
    //     pm.response.to.not.be.success
    //     pm.response.to.not.be.info
    // })
    //
    // pm.test('Should not be an internal server error', () => {
    //     pm.response.to.not.be.serverError
    // })
%}

###
# group: User / Follow and Unfollow
# @name SecondUser Unfollow FirstUser Fail (No Username)
# Attempts to unfollow the firstUser without providing the username of the secondUser. Should return an error status and no body.
# Expected Status: error
# Expected Body: none
POST localhost:8080/users/@{{firstUser}}/unfollow
Content-Type: application/json

{
  "password": "{{password}}"
}

> {%
    // TODO: migrate to HTTP Client Response handler API
    // pm.test('Status client error', () => {
    //     pm.response.to.not.be.success
    //     pm.response.to.not.be.info
    // })
    //
    // pm.test('Should not be an internal server error', () => {
    //     pm.response.to.not.be.serverError
    // })
%}

###
# group: User / Follow and Unfollow
# @name SecondUser Unfollow FirstUser
# Attempts to unfollow the firstUser without providing the username of the secondUser. Should return an error status and no body.
# Expected Status: error
# Expected Body: none
POST localhost:8080/users/@{{firstUser}}/unfollow
Content-Type: application/json

{
  	"username": "{{secondUser}}",
  	"password": "{{password}}"
}

> {%
    // TODO: migrate to HTTP Client Response handler API
    // pm.test('Should be success', () => {
    //     pm.response.to.be.success
    // })
%}

###
# group: User / Follow and Unfollow
# @name SecondUser Unfollow FirstUser Again
# Attempts to unfollow the firstUser without providing the username of the secondUser. Should return an error status and no body.
# Expected Status: error
# Expected Body: none
POST localhost:8080/users/@{{firstUser}}/unfollow
Content-Type: application/json

{
  	"username": "{{secondUser}}",
  	"password": "{{password}}"
}

> {%
    // TODO: migrate to HTTP Client Response handler API
    // pm.test('Status client error', () => {
    //     pm.response.to.not.be.success
    //     pm.response.to.not.be.info
    // })
    //
    // pm.test('Should not be an internal server error', () => {
    //     pm.response.to.not.be.serverError
    // })
%}

###
# group: User / Follow and Unfollow
# @name Get FirstUser Followers Empty
# Retrieves the followers of the user with the given username. Only active users should be included in the response. If no active user with the given username exists, an error should be sent in lieu of a response.
# #### Response
# ```
# [ // Array of Users
# 	{
# 		"username": "string",
# 		"profile": {
# 			"firstName"?: "string",
# 			"lastName"?: "string",
# 			"email": "string",
# 			"phone"?: "string"
# 		},
# 		"joined": timestamp
# 	}
# ]
# ```
# * Remember that question marks denote optional values.
GET localhost:8080/users/@{{firstUser}}/followers

> {%
    // TODO: migrate to HTTP Client Response handler API
    // const userSchema = pm.environment.get('userSchema')
    //
    // const schema = {
    //     'type': 'array',
    //     'description': 'An array of user dto\'s',
    //     'items': { $ref: userSchema }
    // }
    //
    // pm.test('Status success', () => {
    //     pm.response.to.be.success
    // })
    //
    // pm.test('Schema is valid', () => {
    //   pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true
    // })
    //
    // pm.test('Array to be empty', () => {
    //     pm.expect(pm.response.json().length).to.eql(0)
    // })
%}

###
# group: User / Follow and Unfollow
# @name Get SecondUser Following Empty
# Retrieves the followers of the user with the given username. Only active users should be included in the response. If no active user with the given username exists, an error should be sent in lieu of a response.
# #### Response
# ```
# [ // Array of Users
# 	{
# 		"username": "string",
# 		"profile": {
# 			"firstName"?: "string",
# 			"lastName"?: "string",
# 			"email": "string",
# 			"phone"?: "string"
# 		},
# 		"joined": timestamp
# 	}
# ]
# ```
# * Remember that question marks denote optional values.
GET localhost:8080/users/@{{secondUser}}/following

> {%
    // TODO: migrate to HTTP Client Response handler API
    // const userSchema = pm.environment.get('userSchema')
    //
    // const schema = {
    //     'type': 'array',
    //     'description': 'An array of user dto\'s',
    //     'items': { $ref: userSchema }
    // }
    //
    // pm.test('Status success', () => {
    //     pm.response.to.be.success
    // })
    //
    // pm.test('Schema is valid', () => {
    //   pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true
    // })
    //
    // pm.test('Array to be empty', () => {
    //     pm.expect(pm.response.json().length).to.eql(0)
    // })
%}

###
# group: User / Follow and Unfollow
# @name SecondUser Follow FirstUser After Unfollow
# Attempts to follow the secondUser without providing the username of the firstUser. Should return an error status and no body.
# Expected Status: error
# Expected Body: none
POST localhost:8080/users/@{{firstUser}}/follow
Content-Type: application/json

{
    "username": "{{secondUser}}",
    "password": "{{password}}"
}

> {%
    // TODO: migrate to HTTP Client Response handler API
    // pm.test('Should be success', () => {
    //     pm.response.to.be.success
    // })
%}

###
# group: User / Follow and Unfollow
# @name SecondUser Follow FirstUser Again After Unfollow
# Attempts to follow the secondUser without providing the username of the firstUser. Should return an error status and no body.
# Expected Status: error
# Expected Body: none
POST localhost:8080/users/@{{firstUser}}/follow
Content-Type: application/json

{
    "username": "{{secondUser}}",
    "password": "{{password}}"
}

> {%
    // TODO: migrate to HTTP Client Response handler API
    // pm.test('Status error', () => {
    //     pm.response.to.not.be.success
    // })
    //
    // pm.test('Should not be internal server error', () => {
    //     pm.response.to.not.be.serverError
    // })
%}

###
# group: User / User Feed, Tweets, & Mentions
# @name Get RandomUser Feed
# Retrieves all (non-deleted) tweets authored by the user with the given username, as well as all (non-deleted) tweets authored by users the given user is following. This includes simple tweets, reposts, and replies. The tweets should appear in reverse-chronological order. If no active user with that username exists (deleted or never created), an error should be sent in lieu of a response.
# #### Response
# ```
# [ // Array of Tweets
# 	{
# 		"id": integer,
# 		"author": {
# 			"username": "string",
# 			"profile": {
# 				"firstName"?: "string",
# 				"lastName"?: "string",
# 				"email": "string",
# 				"phone"?: "string"
# 			},
# 			"joined": timestamp
# 		},
# 		"posted": timestamp,
# 		"content"?: "string",
# 		"inReplyTo"?: {Tweet},
# 		"repostOf"?: {Tweet}
# 	}
# ]
# ```
# * Remember that question marks denote optional values.
GET localhost:8080/users/@randomUser/feed

> {%
    // TODO: migrate to HTTP Client Response handler API
    // pm.test('Status error', () => {
    //     pm.response.to.not.be.success
    //     pm.response.to.not.be.info
    // })
    //
    // pm.test('Should not be internal server error', () => {
    //     pm.response.to.not.be.serverError
    // })
%}

###
# group: User / User Feed, Tweets, & Mentions
# @name Get RandomUser Tweets
# Retrieves all (non-deleted) tweets authored by the user with the given username. This includes simple tweets, reposts, and replies. The tweets should appear in reverse-chronological order. If no active user with that username exists (deleted or never created), an error should be sent in lieu of a response.
# #### Response
# ```
# [ // Array of Tweets
# 	{
# 		"id": integer,
# 		"author": {
# 			"username": "string",
# 			"profile": {
# 				"firstName"?: "string",
# 				"lastName"?: "string",
# 				"email": "string",
# 				"phone"?: "string"
# 			},
# 			"joined": timestamp
# 		},
# 		"posted": timestamp,
# 		"content"?: "string",
# 		"inReplyTo"?: {Tweet},
# 		"repostOf"?: {Tweet}
# 	}
# ]
# ```
# * Remember that question marks denote optional values.
GET localhost:8080/users/@randomUser/tweets

> {%
    // TODO: migrate to HTTP Client Response handler API
    // pm.test('Status error', () => {
    //     pm.response.to.not.be.success
    //     pm.response.to.not.be.info
    // })
    //
    // pm.test('Should not be internal server error', () => {
    //     pm.response.to.not.be.serverError
    // })
%}

###
# group: User / User Feed, Tweets, & Mentions
# @name Get RandomUser Mentions
# Retrieves all (non-deleted) tweets in which the user with the given username is mentioned. The tweets should appear in reverse-chronological order. If no active user with that username exists, an error should be sent in lieu of a response.
# A user is considered "mentioned" by a tweet if the tweet has content and the user's username appears in that content following a ```@```.
# #### Response
# ```
# [ // Array of Tweets
# 	{
# 		"id": integer,
# 		"author": {
# 			"username": "string",
# 			"profile": {
# 				"firstName"?: "string",
# 				"lastName"?: "string",
# 				"email": "string",
# 				"phone"?: "string"
# 			},
# 			"joined": timestamp
# 		},
# 		"posted": timestamp,
# 		"content"?: "string",
# 		"inReplyTo"?: {Tweet},
# 		"repostOf"?: {Tweet}
# 	}
# ]
# ```
# * Remember that question marks denote optional values.
GET localhost:8080/users/@randomUser/mentions

> {%
    // TODO: migrate to HTTP Client Response handler API
    // pm.test('Status error', () => {
    //     pm.response.to.not.be.success
    //     pm.response.to.not.be.info
    // })
    //
    // pm.test('Should not be internal server error', () => {
    //     pm.response.to.not.be.serverError
    // })
%}

###
# group: User / User Feed, Tweets, & Mentions
# @name Get SecondUser Feed
# Retrieves all (non-deleted) tweets authored by the user with the given username, as well as all (non-deleted) tweets authored by users the given user is following. This includes simple tweets, reposts, and replies. The tweets should appear in reverse-chronological order. If no active user with that username exists (deleted or never created), an error should be sent in lieu of a response.
# #### Response
# ```
# [ // Array of Tweets
# 	{
# 		"id": integer,
# 		"author": {
# 			"username": "string",
# 			"profile": {
# 				"firstName"?: "string",
# 				"lastName"?: "string",
# 				"email": "string",
# 				"phone"?: "string"
# 			},
# 			"joined": timestamp
# 		},
# 		"posted": timestamp,
# 		"content"?: "string",
# 		"inReplyTo"?: {Tweet},
# 		"repostOf"?: {Tweet}
# 	}
# ]
# ```
# * Remember that question marks denote optional values.
GET localhost:8080/users/@{{secondUser}}/feed

> {%
    // TODO: migrate to HTTP Client Response handler API
    // const tweetSchema = pm.environment.get('tweetSchema')
    //
    // const schema = {
    //     type: 'array',
    //     description: 'An array of tweet dto\'s',
    //     items: { $ref: tweetSchema }
    // }
    //
    // pm.test('Status success', () => {
    //     pm.response.to.be.success
    // })
    //
    // pm.test('Schema is valid', () => {
    //   pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true
    // })
    //
%}

###
# group: User / User Feed, Tweets, & Mentions
# @name Get SecondUser Tweets Empty
# Retrieves all (non-deleted) tweets authored by the user with the given username. This includes simple tweets, reposts, and replies. The tweets should appear in reverse-chronological order. If no active user with that username exists (deleted or never created), an error should be sent in lieu of a response.
# #### Response
# ```
# [ // Array of Tweets
# 	{
# 		"id": integer,
# 		"author": {
# 			"username": "string",
# 			"profile": {
# 				"firstName"?: "string",
# 				"lastName"?: "string",
# 				"email": "string",
# 				"phone"?: "string"
# 			},
# 			"joined": timestamp
# 		},
# 		"posted": timestamp,
# 		"content"?: "string",
# 		"inReplyTo"?: {Tweet},
# 		"repostOf"?: {Tweet}
# 	}
# ]
# ```
# * Remember that question marks denote optional values.
GET localhost:8080/users/@{{secondUser}}/tweets

> {%
    // TODO: migrate to HTTP Client Response handler API
    // const tweetSchema = pm.environment.get('tweetSchema')
    //
    // const schema = {
    //     type: 'array',
    //     description: 'An array of tweet dto\'s',
    //     items: { $ref: tweetSchema }
    // }
    //
    // pm.test('Status success', () => {
    //     pm.response.to.be.success
    // })
    //
    // pm.test('Schema is valid', () => {
    //   pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true
    // })
    //
    // if (pm.response.code >= 200 && pm.response.code < 300 && pm.response.json() !== null && Array.isArray(pm.response.json())) {
    //     pm.test('Should be empty', () => {
    //         pm.expect(pm.response.json().length).to.eql(0)
    //     })
    // }
%}

###
# group: User / Delete User
# @name Delete RandomUser
# "Deletes" a user with the given username. If no such user exists or the provided credentials do not match the user, an error should be sent in lieu of a response. If a user is successfully "deleted", the response should contain the user data prior to deletion.
# **IMPORTANT**: This action should not actually drop any records from the database! Instead, develop a way to keep track of "deleted" users so that if a user is re-activated, all of their tweets and information are restored.
# #### Request
# ```
# {
# 	"credentials": {
# 		"username": "string",
# 		"password": "string"
# 	}
# }
# ```
# #### Response
# ```
# { // User
# 	"username": "string",
# 	"profile": {
# 		"firstName"?: "string",
# 		"lastName"?: "string",
# 		"email": "string",
# 		"phone"?: "string"
# 	},
# 	"joined": timestamp
# }
# ```
# * Remember that question marks denote optional values.
DELETE localhost:8080/users/@randomUser
Content-Type: application/json

{
  "credentials": {
    "username": "{{firstUser}}",
    "password": "{{password}}"
  }
}

> {%
    // TODO: migrate to HTTP Client Response handler API
    // pm.test('Status not success', () => {
    //     pm.response.to.not.be.success
    //     pm.response.to.not.be.info
    // })
    //
    // pm.test('Should not be an internal server error', () => {
    //     pm.response.to.not.be.serverError
    // })
%}

###
# group: User / Delete User
# @name Delete FirstUser
# "Deletes" a user with the given username. If no such user exists or the provided credentials do not match the user, an error should be sent in lieu of a response. If a user is successfully "deleted", the response should contain the user data prior to deletion.
# **IMPORTANT**: This action should not actually drop any records from the database! Instead, develop a way to keep track of "deleted" users so that if a user is re-activated, all of their tweets and information are restored.
# #### Request
# ```
# {
# 	"credentials": {
# 		"username": "string",
# 		"password": "string"
# 	}
# }
# ```
# #### Response
# ```
# { // User
# 	"username": "string",
# 	"profile": {
# 		"firstName"?: "string",
# 		"lastName"?: "string",
# 		"email": "string",
# 		"phone"?: "string"
# 	},
# 	"joined": timestamp
# }
# ```
# * Remember that question marks denote optional values.
DELETE localhost:8080/users/@{{firstUser}}
Content-Type: application/json

{
    "username": "{{firstUser}}",
    "password": "{{password}}"
}

> {%
    // TODO: migrate to HTTP Client Response handler API
    // const schema = pm.environment.get('userSchema')
    //
    //
    // pm.test('Success status', () => {
    //     pm.response.to.be.success
    // })
    //
    // pm.test('Schema is valid', () => {
    //   pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true
    // })
    //
    // pm.test('Username is correct', () => {
    //     pm.expect(pm.response.json().username).to.eql(pm.environment.get('firstUser'))
    // })
    //
    // pm.test('Joined has not been modified', () => {
    //     pm.expect(new Date(pm.response.json().joined)).to.eql(new Date(pm.environment.get('firstUserJoined')))
    // })
    //
    // pm.test('Profile is correct', () => {
    //     const profile = pm.response.json().profile
    //     pm.expect(profile.firstName).to.eql(pm.environment.get('firstUserFirstName'))
    //     pm.expect(profile.lastName).to.eql(pm.environment.get('firstUserLastName'))
    //     pm.expect(profile.email).to.eql(pm.environment.get('firstUserEmail'))
    //     pm.expect(profile.phone).to.eql(pm.environment.get('firstUserPhone'))
    // })
%}

###
# group: User / Delete User
# @name Create FirstUser After Delete
# If a user tries to create a user without a username, an error code of some kind should be sent in leu of a response.
# Expected Status: An "error" status code. Somewhere in the 400s or 500s.
# No Response Body expected. If the student adds more advanced error handling though, we should not penalize them.
POST localhost:8080/users
Content-Type: application/json

{
  "credentials": {
  	"username": "{{firstUser}}",
    "password": "{{password}}"
  },
  "profile": {
    "email": "{{firstUserEmail}}",
    "firstName": "{{firstUserFirstName}}",
    "lastName": "{{firstUserLastName}}",
    "phone": "{{firstUserPhone}}"
  }
}

> {%
    // TODO: migrate to HTTP Client Response handler API
    // const schema = pm.environment.get('userSchema')
    //
    // pm.test('Success status', () => {
    //     pm.response.to.be.success
    // })
    //
    // pm.test('Schema is valid', () => {
    //   pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true
    // })
    //
    // pm.test('Username was set correctly', () => {
    //     pm.expect(pm.response.json().username).to.eql(pm.environment.get('firstUser'))
    // })
    //
    // pm.test('Joined date was set', () => {
    //     const joined = pm.response.json().joined
    //     pm.expect(joined).to.not.eql(null)
    //     pm.expect(joined).to.not.eql(undefined)
    //     pm.environment.set('firstUserJoined', new Date(joined))
    // })
    //
    // pm.test('Profile was set correctly', () => {
    //     const profile = pm.response.json().profile
    //     pm.expect(profile.firstName).to.eql(pm.environment.get('firstUserFirstName'))
    //     pm.expect(profile.lastName).to.eql(pm.environment.get('firstUserLastName'))
    //     pm.expect(profile.email).to.eql(pm.environment.get('firstUserEmail'))
    //     pm.expect(profile.phone).to.eql(pm.environment.get('firstUserPhone'))
    // })
%}

###
# group: User / Delete User
# @name Create FirstUser After Delete Again
# If a user tries to create a user without a username, an error code of some kind should be sent in leu of a response.
# Expected Status: An "error" status code. Somewhere in the 400s or 500s.
# No Response Body expected. If the student adds more advanced error handling though, we should not penalize them.
POST localhost:8080/users
Content-Type: application/json

{
  "credentials": {
  	"username": "{{firstUser}}",
    "password": "{{password}}"
  },
  "profile": {
    "email": "{{firstUserEmail}}",
    "firstName": "{{firstUserFirstName}}",
    "lastName": "{{firstUserLastName}}",
    "phone": "{{firstUserPhone}}"
  }
}

> {%
    // TODO: migrate to HTTP Client Response handler API
    // pm.test('Error status', () => {
    //     pm.response.to.not.be.info
    //     pm.response.to.not.be.success
    // })
    //
    // pm.test('Should not be internal server error', () => {
    //     pm.response.to.not.be.serverError
    // })
    //
%}

###
# group: Tweet / Create New Tweets
# @name Get All Tags
# Retrieves all hashtags tracked by the database.
# Response:
# [
#   {
#     "firstUsed": {firstUsedDate},
#     "label": "{label}",
#     "lastUsed": {lastUsedDate}
#   }
# ]
GET localhost:8080/tags

> {%
    // TODO: migrate to HTTP Client Response handler API
    // const hashtagSchema = pm.environment.get('hashtagSchema')
    //
    // const schema = {
    //     type: 'array',
    //     description: 'An array of user dto\'s',
    //     items: { $ref: hashtagSchema }
    // }
    //
    // pm.test('Status success', () => {
    //     pm.response.to.be.success
    // })
    //
    // pm.test('Schema is valid', () => {
    //   pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true
    // })
%}

###
# group: Tweet / Create New Tweets
# @name FirstUser Post Tweet Fail (No Content)
# Attempts to create a tweet with no content. Should return an error status with no content.
# Expected Status: error
# Expected Body: none
POST localhost:8080/tweets
Content-Type: application/json

{
  "credentials": {
    "username": "{{firstUser}}",
    "password": "{{password}}"
  }
}

> {%
    // TODO: migrate to HTTP Client Response handler API
    // pm.test('Status not success', () => {
    //     pm.response.to.not.be.success
    // })
    //
    // pm.test('Should not be an internal server error', () => {
    //     pm.response.to.not.be.serverError
    // })
%}

###
# group: Tweet / Create New Tweets
# @name FirstUser Post Tweet Fail (No Credentials)
# Attempts to create a tweet with no credentials. Should return an error status with no content.
# Expected Status: error
# Expected Body: none
POST localhost:8080/tweets
Content-Type: application/json

{
  "content": "{{firstUserTweet}}"
}

> {%
    // TODO: migrate to HTTP Client Response handler API
    // pm.test('Status not success', () => {
    //     pm.response.to.not.be.success
    // })
    //
    // pm.test('Should not be an internal server error', () => {
    //     pm.response.to.not.be.serverError
    // })
%}

###
# group: Tweet / Create New Tweets
# @name FirstUser Post Tweet Fail (No Password)
# Attempts to create a tweet with no password in the credentials. Should return an error status with no content.
# Expected Status: error
# Expected Body: none
POST localhost:8080/tweets
Content-Type: application/json

{
  "content": "{{firstUserTweet}}",
  "credentials": {
    "username": "{{firstUser}}"
  }
}

> {%
    // TODO: migrate to HTTP Client Response handler API
    // pm.test('Status not success', () => {
    //     pm.response.to.not.be.success
    // })
    //
    // pm.test('Should not be an internal server error', () => {
    //     pm.response.to.not.be.serverError
    // })
%}

###
# group: Tweet / Create New Tweets
# @name FirstUser Post Tweet Fail (No Username)
# Attempts to create a tweet with no username in the credentials. Should return an error status with no content.
# Expected Status: error
# Expected Body: none
POST localhost:8080/tweets
Content-Type: application/json

{
  "content": "{{firstUserTweet}}",
  "credentials": {
    "password": "{{password}}"
  }
}

> {%
    // TODO: migrate to HTTP Client Response handler API
    // pm.test('Status not success', () => {
    //     pm.response.to.not.be.success
    // })
    //
    // pm.test('Should not be an internal server error', () => {
    //     pm.response.to.not.be.serverError
    // })
%}

###
# group: Tweet / Create New Tweets
# @name FirstUser Post Tweet
# Creates a new simple tweet, with the author set to the user indentified by the credentials in the request body. If the given credentials do not match an active user in the database, an error should be sent in lieu of a resopnse.
# The response should contain the newly-created tweet.
# Because this always creates a simple tweet, it must have a content property and may not have inReplyTo or repostOf properties.
# IMPORTANT: when a tweet with content is created, the server must process the tweet's content for @{username} mentions and #{hashtag} tags. There is no way to create hashtags or create mentions from the API, so this must be handled automatically!
# Request:
# {
#   "content": "{content}",
#   "credentials": {
#     "username": "{username}"
#     "password": "{password}"
#   }
# }
# Response:
# {
#   "id": {id},
#   "content": "{content}",
#   "posted": {postedDate}
#   "author": {
#     "username": "{username}",
#     "joined": {joinedDate},
#     "profile": {
#       "email": "{email}",
#       "firstName": "{firstname}",
#       "lastName": "{lastname}",
#       "phone": "{phoneNumber}"
#     }
#   }
# }
POST localhost:8080/tweets
Content-Type: application/json

{
  "content": "{{firstUserTweet}}",
  "credentials": {
    "username": "{{firstUser}}",
    "password": "{{password}}"
  }
}

> {%
    // TODO: migrate to HTTP Client Response handler API
    // const schema = pm.environment.get('tweetSchema')
    //
    // pm.test('Schema is valid', () => {
    //     pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true
    // })
    //
    // pm.test('Tweet has id', () => {
    //     pm.expect(pm.response.json().id).to.not.eql(null)
    //     pm.environment.set('firstTweetId', pm.response.json().id)
    // })
    //
    // pm.test('Author is correct', () => {
    //     const author = pm.response.json().author
    //     pm.expect(author.username).to.eql(pm.environment.get('firstUser'))
    //     pm.expect(new Date(author.joined)).to.eql(new Date(pm.environment.get('firstUserJoined')))
    //     const profile = author.profile
    //     pm.expect(profile.firstName).to.eql(pm.environment.get('firstUserFirstName'))
    //     pm.expect(profile.lastName).to.eql(pm.environment.get('firstUserLastName'))
    //     pm.expect(profile.email).to.eql(pm.environment.get('firstUserEmail'))
    //     pm.expect(profile.phone).to.eql(pm.environment.get('firstUserPhone'))
    // })
    //
    // pm.test('Tweet has date posted', () => {
    //     pm.expect(pm.response.json().posted).to.not.eql(null)
    // })
    //
    // pm.test('Tweet content is correct', () => {
    //     pm.expect(pm.response.json().content).to.eql(`Tweet from the first user! @${pm.environment.get('secondUser')} #${pm.environment.get('firstTag')}`)
    // })
%}

###
# group: Tweet / Create New Tweets
# @name Get FirstUser Feed
# Retrieves all (non-deleted) tweets authored by the user with the given username, as well as all (non-deleted) tweets authored by users the given user is following. This includes simple tweets, reposts, and replies. The tweets should appear in reverse-chronological order. If no active user with that username exists (deleted or never created), an error should be sent in lieu of a response.
# #### Response
# ```
# [ // Array of Tweets
# 	{
# 		"id": integer,
# 		"author": {
# 			"username": "string",
# 			"profile": {
# 				"firstName"?: "string",
# 				"lastName"?: "string",
# 				"email": "string",
# 				"phone"?: "string"
# 			},
# 			"joined": timestamp
# 		},
# 		"posted": timestamp,
# 		"content"?: "string",
# 		"inReplyTo"?: {Tweet},
# 		"repostOf"?: {Tweet}
# 	}
# ]
# ```
# * Remember that question marks denote optional values.
GET localhost:8080/users/@{{firstUser}}/feed

> {%
    // TODO: migrate to HTTP Client Response handler API
    // const tweetSchema = pm.environment.get('tweetSchema')
    //
    // const schema = {
    //     type: 'array',
    //     description: 'An array of tweet dto\'s',
    //     items: { $ref: tweetSchema }
    // }
    //
    // pm.test('Status success', () => {
    //     pm.response.to.be.success
    // })
    //
    // pm.test('Schema is valid', () => {
    //   pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true
    // })
    //
    // if (pm.response.code >= 200 && pm.response.code < 300 && pm.response.json() !== null && Array.isArray(pm.response.json())) {
    //     const content = pm.response.json().map(tweet => tweet.content)
    //     const authors = pm.response.json().map(tweet => tweet.author.username)
    //     
    //     pm.test('Contains the firstUser\'s tweet', () => {
    //         pm.expect(content).to.include(`Tweet from the first user! @${pm.environment.get('secondUser')} #${pm.environment.get('firstTag')}`)
    //         pm.expect(authors).to.include(pm.environment.get('firstUser'))
    //     })
    // }
%}

###
# group: Tweet / Create New Tweets
# @name Get FirstUser Tweets
# Retrieves all (non-deleted) tweets authored by the user with the given username. This includes simple tweets, reposts, and replies. The tweets should appear in reverse-chronological order. If no active user with that username exists (deleted or never created), an error should be sent in lieu of a response.
# #### Response
# ```
# [ // Array of Tweets
# 	{
# 		"id": integer,
# 		"author": {
# 			"username": "string",
# 			"profile": {
# 				"firstName"?: "string",
# 				"lastName"?: "string",
# 				"email": "string",
# 				"phone"?: "string"
# 			},
# 			"joined": timestamp
# 		},
# 		"posted": timestamp,
# 		"content"?: "string",
# 		"inReplyTo"?: {Tweet},
# 		"repostOf"?: {Tweet}
# 	}
# ]
# ```
# * Remember that question marks denote optional values.
GET localhost:8080/users/@{{firstUser}}/tweets

> {%
    // TODO: migrate to HTTP Client Response handler API
    // const tweetSchema = pm.environment.get('tweetSchema')
    //
    // const schema = {
    //     type: 'array',
    //     description: 'An array of tweet dto\'s',
    //     items: { $ref: tweetSchema }
    // }
    //
    // pm.test('Status success', () => {
    //     pm.response.to.be.success
    // })
    //
    // pm.test('Schema is valid', () => {
    //   pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true
    // })
    //
    // if (pm.response.code >= 200 && pm.response.code < 300 && pm.response.json() !== null && Array.isArray(pm.response.json())) {
    //     const content = pm.response.json().map(tweet => tweet.content)
    //     const authors = pm.response.json().map(tweet => tweet.author.username)
    //     
    //     pm.test('Only contains the firstUser\'s tweet', () => {
    //         pm.expect(content).to.include(`Tweet from the first user! @${pm.environment.get('secondUser')} #${pm.environment.get('firstTag')}`)
    //         pm.expect(authors).to.include(pm.environment.get('firstUser'))
    //         pm.expect(authors).to.not.include(pm.environment.get('secondUser'))
    //     })
    // }
%}

###
# group: Tweet / Create New Tweets
# @name Get FirstUser Mentions
# Retrieves all (non-deleted) tweets in which the user with the given username is mentioned. The tweets should appear in reverse-chronological order. If no active user with that username exists, an error should be sent in lieu of a response.
# A user is considered "mentioned" by a tweet if the tweet has content and the user's username appears in that content following a ```@```.
# #### Response
# ```
# [ // Array of Tweets
# 	{
# 		"id": integer,
# 		"author": {
# 			"username": "string",
# 			"profile": {
# 				"firstName"?: "string",
# 				"lastName"?: "string",
# 				"email": "string",
# 				"phone"?: "string"
# 			},
# 			"joined": timestamp
# 		},
# 		"posted": timestamp,
# 		"content"?: "string",
# 		"inReplyTo"?: {Tweet},
# 		"repostOf"?: {Tweet}
# 	}
# ]
# ```
# * Remember that question marks denote optional values.
GET localhost:8080/users/@{{firstUser}}/mentions

> {%
    // TODO: migrate to HTTP Client Response handler API
    // const tweetSchema = pm.environment.get('tweetSchema')
    //
    // const schema = {
    //     type: 'array',
    //     description: 'An array of tweet dto\'s',
    //     items: { $ref: tweetSchema }
    // }
    //
    // pm.test('Status success', () => {
    //     pm.response.to.be.success
    // })
    //
    // pm.test('Schema is valid', () => {
    //   pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true
    // })
    //
    // if (pm.response.code >= 200 && pm.response.code < 300 && pm.response.json() !== null && Array.isArray(pm.response.json())) {
    //     if (pm.response.json().length > 0) {
    //         const authors = pm.response.json().map(tweet => tweet.author.username)
    //         pm.test('Should only contain tweets by secondUser', () => {
    //             pm.expect(authors).to.include(pm.environment.get('secondUser'))
    //             pm.expect(authors).to.not.include(pm.environment.get('firstUser'))
    //         })
    //     } else {
    //         pm.test('Should be empty', () => {
    //             pm.expect(pm.response.json().length).to.eql(0)
    //         })
    //     }
    // }
%}

###
# group: Tweet / Create New Tweets
# @name Get SecondUser Mentions
# Retrieves all (non-deleted) tweets in which the user with the given username is mentioned. The tweets should appear in reverse-chronological order. If no active user with that username exists, an error should be sent in lieu of a response.
# A user is considered "mentioned" by a tweet if the tweet has content and the user's username appears in that content following a ```@```.
# #### Response
# ```
# [ // Array of Tweets
# 	{
# 		"id": integer,
# 		"author": {
# 			"username": "string",
# 			"profile": {
# 				"firstName"?: "string",
# 				"lastName"?: "string",
# 				"email": "string",
# 				"phone"?: "string"
# 			},
# 			"joined": timestamp
# 		},
# 		"posted": timestamp,
# 		"content"?: "string",
# 		"inReplyTo"?: {Tweet},
# 		"repostOf"?: {Tweet}
# 	}
# ]
# ```
# * Remember that question marks denote optional values.
GET localhost:8080/users/@{{secondUser}}/mentions

> {%
    // TODO: migrate to HTTP Client Response handler API
    // const tweetSchema = pm.environment.get('tweetSchema')
    //
    // const schema = {
    //     type: 'array',
    //     description: 'An array of tweet dto\'s',
    //     items: { $ref: tweetSchema }
    // }
    //
    // pm.test('Status success', () => {
    //     pm.response.to.be.success
    // })
    //
    // pm.test('Schema is valid', () => {
    //   pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true
    // })
    //
    // if (pm.response.code >= 200 && pm.response.code < 300 && pm.response.json() !== null && Array.isArray(pm.response.json())) {
    //     const content = pm.response.json().map(tweet => tweet.content)
    //     const authors = pm.response.json().map(tweet => tweet.author.username)
    //     
    //     pm.test('Contains the firstUser\'s tweet', () => {
    //         pm.expect(content).to.include(`Tweet from the first user! @${pm.environment.get('secondUser')} #${pm.environment.get('firstTag')}`)
    //         pm.expect(authors).to.include(pm.environment.get('firstUser'))
    //     })
    // }
%}

###
# group: Tweet / Create New Tweets
# @name SecondUser Post Tweet
# Creates a new simple tweet, with the author set to the user indentified by the credentials in the request body. If the given credentials do not match an active user in the database, an error should be sent in lieu of a resopnse.
# The response should contain the newly-created tweet.
# Because this always creates a simple tweet, it must have a content property and may not have inReplyTo or repostOf properties.
# IMPORTANT: when a tweet with content is created, the server must process the tweet's content for @{username} mentions and #{hashtag} tags. There is no way to create hashtags or create mentions from the API, so this must be handled automatically!
# Request:
# {
#   "content": "{content}",
#   "credentials": {
#     "username": "{username}"
#     "password": "{password}"
#   }
# }
# Response:
# {
#   "id": {id},
#   "content": "{content}",
#   "posted": {postedDate}
#   "author": {
#     "username": "{username}",
#     "joined": {joinedDate},
#     "profile": {
#       "email": "{email}",
#       "firstName": "{firstname}",
#       "lastName": "{lastname}",
#       "phone": "{phoneNumber}"
#     }
#   }
# }
POST localhost:8080/tweets
Content-Type: application/json

{
  "content": "{{secondUserTweet}}",
  "credentials": {
    "username": "{{secondUser}}",
    "password": "{{password}}"
  }
}

> {%
    // TODO: migrate to HTTP Client Response handler API
    // const schema = pm.environment.get('tweetSchema')
    //
    // pm.test("Schema is valid", () => {
    //     pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true
    // })
    //
    // pm.test("Tweet has id", () => {
    //     pm.expect(pm.response.json().id).to.not.eql(null)
    //     pm.environment.set("secondTweetId", pm.response.json().id)
    // })
    //
    // pm.test("Author is correct", () => {
    //     const author = pm.response.json().author
    //     pm.expect(author.username).to.eql(pm.environment.get("secondUser"))
    //     pm.expect(new Date(author.joined)).to.eql(new Date(pm.environment.get("secondUserJoined")))
    //     const profile = author.profile
    //     pm.expect(profile.firstName).to.eql(pm.environment.get("secondUserFirstName"))
    //     pm.expect(profile.lastName).to.eql(pm.environment.get("secondUserLastName"))
    //     pm.expect(profile.email).to.eql(pm.environment.get("secondUserEmail"))
    //     pm.expect(profile.phone).to.eql(pm.environment.get("secondUserPhone"))
    // })
    //
    // pm.test("Tweet has date posted", () => {
    //     pm.expect(pm.response.json().posted).to.not.eql(null)
    // })
    //
    // pm.test("Tweet content is correct", () => {
    //     pm.expect(pm.response.json().content).to.eql(`Tweet from the second user! @${pm.environment.get("firstUser")} #${pm.environment.get("secondTag")}`)
    // })
%}

###
# group: Tweet / Create New Tweets
# @name Get SecondUser Feed
# Retrieves all (non-deleted) tweets authored by the user with the given username, as well as all (non-deleted) tweets authored by users the given user is following. This includes simple tweets, reposts, and replies. The tweets should appear in reverse-chronological order. If no active user with that username exists (deleted or never created), an error should be sent in lieu of a response.
# #### Response
# ```
# [ // Array of Tweets
# 	{
# 		"id": integer,
# 		"author": {
# 			"username": "string",
# 			"profile": {
# 				"firstName"?: "string",
# 				"lastName"?: "string",
# 				"email": "string",
# 				"phone"?: "string"
# 			},
# 			"joined": timestamp
# 		},
# 		"posted": timestamp,
# 		"content"?: "string",
# 		"inReplyTo"?: {Tweet},
# 		"repostOf"?: {Tweet}
# 	}
# ]
# ```
# * Remember that question marks denote optional values.
GET localhost:8080/users/@{{secondUser}}/feed

> {%
    // TODO: migrate to HTTP Client Response handler API
    // const tweetSchema = pm.environment.get('tweetSchema')
    //
    // const schema = {
    //     type: 'array',
    //     description: 'An array of tweet dto\'s',
    //     items: { $ref: tweetSchema }
    // }
    //
    // pm.test('Status success', () => {
    //     pm.response.to.be.success
    // })
    //
    // pm.test('Schema is valid', () => {
    //   pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true
    // })
    //
    // if (pm.response.code >= 200 && pm.response.code < 300 && pm.response.json() !== null && Array.isArray(pm.response.json())) {
    //     const content = pm.response.json().map(tweet => tweet.content)
    //     const authors = pm.response.json().map(tweet => tweet.author.username)
    //     
    //     pm.test('Contains the firstUser\'s tweet', () => {
    //         pm.expect(content).to.include(`Tweet from the first user! @${pm.environment.get('secondUser')} #${pm.environment.get('firstTag')}`)
    //         pm.expect(authors).to.include(pm.environment.get('firstUser'))
    //     })
    //     
    //     pm.test('Contains the secondUser\'s tweet', () => {
    //         pm.expect(content).to.include(`Tweet from the second user! @${pm.environment.get('firstUser')} #${pm.environment.get('secondTag')}`)
    //         pm.expect(authors).to.include(pm.environment.get('secondUser'))
    //     })
    // }
%}

###
# group: Tweet / Create New Tweets
# @name Get SecondUser Tweets
# Retrieves all (non-deleted) tweets authored by the user with the given username. This includes simple tweets, reposts, and replies. The tweets should appear in reverse-chronological order. If no active user with that username exists (deleted or never created), an error should be sent in lieu of a response.
# #### Response
# ```
# [ // Array of Tweets
# 	{
# 		"id": integer,
# 		"author": {
# 			"username": "string",
# 			"profile": {
# 				"firstName"?: "string",
# 				"lastName"?: "string",
# 				"email": "string",
# 				"phone"?: "string"
# 			},
# 			"joined": timestamp
# 		},
# 		"posted": timestamp,
# 		"content"?: "string",
# 		"inReplyTo"?: {Tweet},
# 		"repostOf"?: {Tweet}
# 	}
# ]
# ```
# * Remember that question marks denote optional values.
GET localhost:8080/users/@{{secondUser}}/tweets

> {%
    // TODO: migrate to HTTP Client Response handler API
    // const tweetSchema = pm.environment.get('tweetSchema')
    //
    // const schema = {
    //     type: 'array',
    //     description: 'An array of tweet dto\'s',
    //     items: { $ref: tweetSchema }
    // }
    //
    // pm.test('Status success', () => {
    //     pm.response.to.be.success
    // })
    //
    // pm.test('Schema is valid', () => {
    //   pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true
    // })
    //
    // if (pm.response.code >= 200 && pm.response.code < 300 && pm.response.json() !== null && Array.isArray(pm.response.json())) {
    //     const content = pm.response.json().map(tweet => tweet.content)
    //     const authors = pm.response.json().map(tweet => tweet.author.username)
    //     
    //     pm.test('Only contains the secondUser\'s tweet', () => {
    //         pm.expect(content).to.include(`Tweet from the second user! @${pm.environment.get('firstUser')} #${pm.environment.get('secondTag')}`)
    //         pm.expect(authors).to.include(pm.environment.get('secondUser'))
    //         pm.expect(authors).to.not.include(pm.environment.get('firstUser'))
    //     })
    // }
%}

###
# group: Tweet / Create New Tweets
# @name Get FirstUser Mentions
# Retrieves all (non-deleted) tweets in which the user with the given username is mentioned. The tweets should appear in reverse-chronological order. If no active user with that username exists, an error should be sent in lieu of a response.
# A user is considered "mentioned" by a tweet if the tweet has content and the user's username appears in that content following a ```@```.
# #### Response
# ```
# [ // Array of Tweets
# 	{
# 		"id": integer,
# 		"author": {
# 			"username": "string",
# 			"profile": {
# 				"firstName"?: "string",
# 				"lastName"?: "string",
# 				"email": "string",
# 				"phone"?: "string"
# 			},
# 			"joined": timestamp
# 		},
# 		"posted": timestamp,
# 		"content"?: "string",
# 		"inReplyTo"?: {Tweet},
# 		"repostOf"?: {Tweet}
# 	}
# ]
# ```
# * Remember that question marks denote optional values.
GET localhost:8080/users/@{{firstUser}}/mentions

> {%
    // TODO: migrate to HTTP Client Response handler API
    // const tweetSchema = pm.environment.get('tweetSchema')
    //
    // const schema = {
    //     type: 'array',
    //     description: 'An array of tweet dto\'s',
    //     items: { $ref: tweetSchema }
    // }
    //
    // pm.test('Status success', () => {
    //     pm.response.to.be.success
    // })
    //
    // pm.test('Schema is valid', () => {
    //   pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true
    // })
    //
    // if (pm.response.code >= 200 && pm.response.code < 300 && pm.response.json() !== null && Array.isArray(pm.response.json())) {
    //     const content = pm.response.json().map(tweet => tweet.content)
    //     const authors = pm.response.json().map(tweet => tweet.author.username)
    //     
    //     pm.test('Contains the secondUser\'s tweet', () => {
    //         pm.expect(content).to.include(`Tweet from the second user! @${pm.environment.get('firstUser')} #${pm.environment.get('secondTag')}`)
    //         pm.expect(authors).to.include(pm.environment.get('secondUser'))
    //     })
    // }
%}

###
# group: Tweet / Tweet Tags and Mentions
# @name Get RandomTweet Tags
# Retrieves the tags associated with the tweet with the given id. If that tweet is deleted or otherwise doesn't exist, an error should be sent in lieu of a resonse.
# IMPORTANT: Remember that tags and mentions must be parsed by the server!
# Response:
# [
#   {
#     "firstUsed": {firstUsedDate},
#     "label": "{label}",
#     "lastUsed": {lastUsedDate}
#   }
# ]
GET localhost:8080/tweets/randomTweet/tags

> {%
    // TODO: migrate to HTTP Client Response handler API
    // pm.test('Status error', () => {
    //     pm.response.to.not.be.success
    //     pm.response.to.not.be.info
    // })
    //
    // pm.test('Should not be internal server error', () => {
    //     pm.response.to.not.be.serverError
    // })
%}

###
# group: Tweet / Tweet Tags and Mentions
# @name Get FirstTweet Tags
# Retrieves the tags associated with the tweet with the given id. If that tweet is deleted or otherwise doesn't exist, an error should be sent in lieu of a resonse.
# IMPORTANT: Remember that tags and mentions must be parsed by the server!
# Response:
# [
#   {
#     "firstUsed": {firstUsedDate},
#     "label": "{label}",
#     "lastUsed": {lastUsedDate}
#   }
# ]
GET localhost:8080/tweets/{{firstTweetId}}/tags

> {%
    // TODO: migrate to HTTP Client Response handler API
    // const hashtagSchema = pm.environment.get('hashtagSchema')
    //
    // const schema = {
    //     type: 'array',
    //     description: 'An array of hashtag dto\'s',
    //     items: { $ref: hashtagSchema }
    // }
    //
    // pm.test('Status success', () => {
    //     pm.response.to.be.success
    // })
    //
    // pm.test('Schema is valid', () => {
    //   pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true
    // })
    //
    // pm.test('Should contain two values', () => {
    //     pm.expect(pm.response.json().length).to.eql(1)
    // })
    //
    // pm.test('Should contain the first hashtag', () => {
    //     const hashtags = pm.response.json().map(hashtag => hashtag.label)
    //     pm.expect(hashtags).to.include(pm.environment.get('firstTag'))
    // })
%}

###
# group: Tweet / Tweet Tags and Mentions
# @name Get SecondTweet Tags
# Retrieves the tags associated with the tweet with the given id. If that tweet is deleted or otherwise doesn't exist, an error should be sent in lieu of a resonse.
# IMPORTANT: Remember that tags and mentions must be parsed by the server!
# Response:
# [
#   {
#     "firstUsed": {firstUsedDate},
#     "label": "{label}",
#     "lastUsed": {lastUsedDate}
#   }
# ]
GET localhost:8080/tweets/{{secondTweetId}}/tags

> {%
    // TODO: migrate to HTTP Client Response handler API
    // const hashtagSchema = pm.environment.get('hashtagSchema')
    //
    // const schema = {
    //     type: 'array',
    //     description: 'An array of hashtag dto\'s',
    //     items: { $ref: hashtagSchema }
    // }
    //
    // pm.test('Status success', () => {
    //     pm.response.to.be.success
    // })
    //
    // pm.test('Schema is valid', () => {
    //   pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true
    // })
    //
    // pm.test('Should contain two values', () => {
    //     pm.expect(pm.response.json().length).to.eql(1)
    // })
    //
    // pm.test('Should contain the second hashtag', () => {
    //     const hashtags = pm.response.json().map(hashtag => hashtag.label)
    //     pm.expect(hashtags).to.include(pm.environment.get('secondTag'))
    // })
%}

###
# group: Tweet / Tweet Tags and Mentions
# @name Get FirstTweet Mentions
# Retrieves the users mentioned in the tweet with the given id. If that tweet is deleted or otherwise doesn't exist, an error should be sent in lieu of a response.
# Deleted users should be excluded from the response.
# IMPORTANT: Remember that tags and mentions must be parsed by the server!
# Response:
# [
#   {
#     "username": "{username}",
#     "joined": {joinedDate},
#     "profile": {
#         "firstName": "{firstName}",
#         "lastName": "{lastName}",
#         "email": "{email}",
#         "phone": "{phoneNumber}"
#     }
#   }
# ]
GET localhost:8080/tweets/{{firstTweetId}}/mentions

> {%
    // TODO: migrate to HTTP Client Response handler API
    // const userSchema = pm.environment.get('userSchema')
    //
    // const schema = {
    //     type: 'array',
    //     description: 'An array of user dto\'s',
    //     items: { $ref: userSchema }
    // }
    //
    // pm.test('Status success', () => {
    //     pm.response.to.be.success
    // })
    //
    // pm.test('Schema is valid', () => {
    //   pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true
    // })
    //
    // pm.test('Returns an with only the second user', () => {
    //     pm.expect(pm.response.json().length).to.eql(1)
    // })
    //
    // if (pm.response.json() !== null && Array.isArray(pm.response.json())) {
    //     const users = pm.response.json().map(user => user.username)
    //     
    //     pm.test('Contains the secondUser', () => {
    //         pm.expect(users).to.include(pm.environment.get('secondUser'))
    //     })
    // }
    //
    //
%}

###
# group: Tweet / Tweet Tags and Mentions
# @name Get SecondTweet Mentions
# Retrieves the users mentioned in the tweet with the given id. If that tweet is deleted or otherwise doesn't exist, an error should be sent in lieu of a response.
# Deleted users should be excluded from the response.
# IMPORTANT: Remember that tags and mentions must be parsed by the server!
# Response:
# [
#   {
#     "username": "{username}",
#     "joined": {joinedDate},
#     "profile": {
#         "firstName": "{firstName}",
#         "lastName": "{lastName}",
#         "email": "{email}",
#         "phone": "{phoneNumber}"
#     }
#   }
# ]
GET localhost:8080/tweets/{{secondTweetId}}/mentions

> {%
    // TODO: migrate to HTTP Client Response handler API
    // const userSchema = pm.environment.get('userSchema')
    //
    // const schema = {
    //     type: 'array',
    //     description: 'An array of user dto\'s',
    //     items: { $ref: userSchema }
    // }
    //
    // pm.test('Status success', () => {
    //     pm.response.to.be.success
    // })
    //
    // pm.test('Schema is valid', () => {
    //   pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true
    // })
    //
    // pm.test('Returns an with only the first user', () => {
    //     pm.expect(pm.response.json().length).to.eql(1)
    // })
    //
    // if (pm.response.json() !== null && Array.isArray(pm.response.json())) {
    //     const users = pm.response.json().map(user => user.username)
    //     
    //     pm.test('Contains the firstUser', () => {
    //         pm.expect(users).to.include(pm.environment.get('firstUser'))
    //     })
    // }
    //
%}

###
# group: Tweet / Get Tweets
# @name Get All Tweets
# Retrieves all (non-deleted) tweets. The tweets should appear in reverse-chronological order.
# Response:
# [
#   {
#     "id": {id},
#     "content": "{content}",
#     "posted": {postedDate}
#     "author": {
#       "username": "{username}",
#       "joined": {joinedDate},
#       "profile": {
#         "email": "{email}",
#         "firstName": "{firstname}",
#         "lastName": "{lastname}",
#         "phone": "{phoneNumber}"
#       }
#     }
#   }
# ]
GET localhost:8080/tweets

> {%
    // TODO: migrate to HTTP Client Response handler API
    // const tweetSchema = pm.environment.get('tweetSchema')
    //
    // const schema = {
    //     type: 'array',
    //     description: 'An array of tweet dto\'s',
    //     items: { $ref: tweetSchema }
    // }
    //
    // pm.test('Status success', () => {
    //     pm.response.to.be.success
    // })
    //
    // pm.test('Schema is valid', () => {
    //   pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true
    // })
    //
    // if (pm.response.code >= 200 && pm.response.code < 300 && pm.response.json() !== null && Array.isArray(pm.response.json())) {
    //     const content = pm.response.json().map(tweet => tweet.content)
    //     const authors = pm.response.json().map(tweet => tweet.author.username)
    //     
    //     pm.test('Contains the firstUser\'s tweet', () => {
    //         pm.expect(content).to.include(`Tweet from the first user! @${pm.environment.get('secondUser')} #${pm.environment.get('firstTag')}`)
    //         pm.expect(authors).to.include(pm.environment.get('firstUser'))
    //     })
    //     
    //     pm.test('Contains the secondUser\'s tweet', () => {
    //         pm.expect(content).to.include(`Tweet from the second user! @${pm.environment.get('firstUser')} #${pm.environment.get('secondTag')}`)
    //         pm.expect(authors).to.include(pm.environment.get('secondUser'))
    //     })
    // }
%}

###
# group: Tweet / Get Tweets
# @name Get FirstTweet
# Retrieves a tweet with a given id. If no such tweet exists, or the given tweet is deleted, an error should be sent in lieu of a response.
# Response:
# {
#   "id": {id},
#   "content": "{content}",
#   "posted": {postedDate}
#   "author": {
#     "username": "{username}",
#     "joined": {joinedDate},
#     "profile": {
#       "email": "{email}",
#       "firstName": "{firstname}",
#       "lastName": "{lastname}",
#       "phone": "{phoneNumber}"
#     }
#   }
# }
GET localhost:8080/tweets/{{firstTweetId}}

> {%
    // TODO: migrate to HTTP Client Response handler API
    // const schema = pm.environment.get('tweetSchema')
    //
    // pm.test('Status success', () => {
    //     pm.response.to.be.success
    // })
    //
    // pm.test('Schema is valid', () => {
    //   pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true
    // })
    //
    // pm.test('Author should be the firstUser', () => {
    //     pm.expect(pm.response.json().author.username).to.eql(pm.environment.get('firstUser'))
    // })
    //
    // pm.test('Content should be the firstTweet', () => {
    //      pm.expect(pm.response.json().content).to.eql(`Tweet from the first user! @${pm.environment.get('secondUser')} #${pm.environment.get('firstTag')}`)
    // })
%}

###
# group: Tweet / Get Tweets
# @name Get SecondTweet
# Retrieves a tweet with a given id. If no such tweet exists, or the given tweet is deleted, an error should be sent in lieu of a response.
# Response:
# {
#   "id": {id},
#   "content": "{content}",
#   "posted": {postedDate}
#   "author": {
#     "username": "{username}",
#     "joined": {joinedDate},
#     "profile": {
#       "email": "{email}",
#       "firstName": "{firstname}",
#       "lastName": "{lastname}",
#       "phone": "{phoneNumber}"
#     }
#   }
# }
GET localhost:8080/tweets/{{secondTweetId}}

> {%
    // TODO: migrate to HTTP Client Response handler API
    // const schema = pm.environment.get('tweetSchema')
    //
    // pm.test('Status success', () => {
    //     pm.response.to.be.success
    // })
    //
    // pm.test('Schema is valid', () => {
    //   pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true
    // })
    //
    // pm.test('Author should be the secondUser', () => {
    //     pm.expect(pm.response.json().author.username).to.eql(pm.environment.get('secondUser'))
    // })
    //
    // pm.test('Content should be the secondTweet', () => {
    //      pm.expect(pm.response.json().content).to.eql(`Tweet from the second user! @${pm.environment.get('firstUser')} #${pm.environment.get('secondTag')}`)
    // })
%}

###
@firstTag = %23mario
# group: Tweet / Get Tweets
# @name Get FirstTag
# Retrieves all (non-deleted) tweets tagged with the given hashtag label. The tweets should appear in reverse-chronological order. If no hashtag with the given label exists, an error should be sent in lieu of a response.
# A tweet is considered "tagged" by a hashtag if the tweet has content and the hashtag's label appears in that content following a #.
# Response:
# [
#   {
#     "id": {id},
#     "content": "{content}",
#     "posted": {postedDate}
#     "author": {
#       "username": "{username}",
#       "joined": {joinedDate},
#       "profile": {
#         "email": "{email}",
#         "firstName": "{firstname}",
#         "lastName": "{lastname}",
#         "phone": "{phoneNumber}"
#       }
#     }
#   }
# ]
GET localhost:8080/tags/{{firstTag}}

> {%
    // TODO: migrate to HTTP Client Response handler API
    // const tweetSchema = pm.environment.get('tweetSchema')
    //
    // const schema = {
    //     type: 'array',
    //     description: 'An array of tweet dto\'s',
    //     items: { $ref: tweetSchema }
    // }
    //
    // pm.test('Status success', () => {
    //     pm.response.to.be.success
    // })
    //
    // pm.test('Schema is valid', () => {
    //   pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true
    // })
    //
    // if (pm.response.code >= 200 && pm.response.code < 300 && pm.response.json() !== null && Array.isArray(pm.response.json())) {
    //     const content = pm.response.json().map(tweet => tweet.content)
    //     const authors = pm.response.json().map(tweet => tweet.author.username)
    //     
    //     pm.test('Should only contain the first user\'s tweets', () => {
    //         pm.expect(authors).to.include(pm.environment.get('firstUser'))
    //         pm.expect(authors).to.not.include(pm.environment.get('secondUser'))
    //     })
    //     
    //     pm.test('Contains the firstUser\'s tweet', () => {
    //         pm.expect(content).to.include(`Tweet from the first user! @${pm.environment.get('secondUser')} #${pm.environment.get('firstTag')}`)
    //         pm.expect(authors).to.include(pm.environment.get('firstUser'))
    //     })
    // }
%}

###
@secondTag =%23luigi
# group: Tweet / Get Tweets
# @name Get SecondTag
# Retrieves all (non-deleted) tweets tagged with the given hashtag label. The tweets should appear in reverse-chronological order. If no hashtag with the given label exists, an error should be sent in lieu of a response.
# A tweet is considered "tagged" by a hashtag if the tweet has content and the hashtag's label appears in that content following a #.
# Response:
# [
#   {
#     "id": {id},
#     "content": "{content}",
#     "posted": {postedDate}
#     "author": {
#       "username": "{username}",
#       "joined": {joinedDate},
#       "profile": {
#         "email": "{email}",
#         "firstName": "{firstname}",
#         "lastName": "{lastname}",
#         "phone": "{phoneNumber}"
#       }
#     }
#   }
# ]
GET localhost:8080/tags/{{secondTag}}

> {%
    // TODO: migrate to HTTP Client Response handler API
    // const tweetSchema = pm.environment.get('tweetSchema')
    //
    // const schema = {
    //     type: 'array',
    //     description: 'An array of tweet dto\'s',
    //     items: { $ref: tweetSchema }
    // }
    //
    // pm.test('Status success', () => {
    //     pm.response.to.be.success
    // })
    //
    // pm.test('Schema is valid', () => {
    //   pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true
    // })
    //
    // if (pm.response.code >= 200 && pm.response.code < 300 && pm.response.json() !== null && Array.isArray(pm.response.json())) {
    //     const content = pm.response.json().map(tweet => tweet.content)
    //     const authors = pm.response.json().map(tweet => tweet.author.username)
    //     
    //     pm.test('Should only contain the second user\'s tweets', () => {
    //         pm.expect(authors).to.include(pm.environment.get('secondUser'))
    //         pm.expect(authors).to.not.include(pm.environment.get('firstUser'))
    //     })
    //     
    //     pm.test('Contains the secondUser\'s tweet', () => {
    //         pm.expect(content).to.include(`Tweet from the second user! @${pm.environment.get('firstUser')} #${pm.environment.get('secondTag')}`)
    //         pm.expect(authors).to.include(pm.environment.get('secondUser'))
    //     })
    // }
%}

###
# group: Tweet / Liking Tweets
# @name FirstUser Like SecondUserTweet
# Creates a "like" relationship between the tweet with the given id and the user whose credentials are provided in the request body. If the tweet is deleted or otherwise doesn't exist, or if the given credentials do not match an active user in the database, an error should be sent. Following successful completion of the operation, no response body is sent.
# Request:
# {
# 	"username": {{username}},
# 	"password": {{password}}
# }
POST localhost:8080/tweets/{{secondTweetId}}/like
Content-Type: application/json

{
  "username": "{{firstUser}}",
  "password": "{{password}}"
}

> {%
    // TODO: migrate to HTTP Client Response handler API
    // pm.test('Should be success', () => {
    //     pm.response.to.be.success
    // })
%}

###
# group: Tweet / Liking Tweets
# @name FirstUser Like SecondUserTweet Again
# Creates a "like" relationship between the tweet with the given id and the user whose credentials are provided in the request body. If the tweet is deleted or otherwise doesn't exist, or if the given credentials do not match an active user in the database, an error should be sent. Following successful completion of the operation, no response body is sent.
# Request:
# {
#   "username": {{username}},
#   "password": {{password}}
# }
POST localhost:8080/tweets/{{secondTweetId}}/like
Content-Type: application/json

{
  "username": "{{firstUser}}",
  "password": "{{password}}"
}

> {%
    // TODO: migrate to HTTP Client Response handler API
    // pm.test('Should be success', () => {
    //     pm.response.to.be.success
    // })
    //
    // pm.test('Should not be internal server error', () => {
    //     pm.response.to.not.be.serverError
    // })
%}

###
# group: Tweet / Liking Tweets
# @name Get SecondTweet Likes
# Retrieves the active users who have liked the tweet with the given id. If that tweet is deleted or otherwise doesn't exist, an error should be sent in lieu of a response.
# Deleted users should be excluded from the response.
# Response:
# [
#   {
#     "username": "{username}",
#     "joined": {joinedDate},
#     "profile": {
#       "firstName": "{firstName}",
#       "lastName": "{lastName}",
#       "email": "{email}",
#       "phone": "{phoneNumber}"
#     }
#   }
# ]
GET localhost:8080/tweets/{{secondTweetId}}/likes

> {%
    // TODO: migrate to HTTP Client Response handler API
    // const userSchema = pm.environment.get('userSchema')
    //
    // const schema = {
    //     type: 'array',
    //     description: 'An array of user dto\'s',
    //     items: { $ref: userSchema }
    // }
    //
    // pm.test('Status success', () => {
    //     pm.response.to.be.success
    // })
    //
    // pm.test('Schema is valid', () => {
    //   pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true
    // })
    //
    // pm.test('Returns an array with one user', () => {
    //     pm.expect(pm.response.json().length).to.eql(1)
    // })
    //
    // if (pm.response.json() !== null && Array.isArray(pm.response.json())) {
    //     const users = pm.response.json().map(user => user.username)
    //     
    //     pm.test('Contains the firstUser', () => {
    //         pm.expect(users).to.include(pm.environment.get('firstUser'))
    //     })
    // }
    //
    //
%}

###
# group: Tweet / Tweet Replies
# @name FirstUser Reply To SecondUserTweet
# Creates a reply tweet to the tweet with the given id. The author of the newly-created tweet should match the credentials provided by the request body. If the given tweet is deleted or otherwise doesn't exist, or if the given credentials do not match an active user in the database, an error should be sent in lieu of a response.
# Because this creates a reply tweet, content is not optional. Additionally, notice that the inReplyTo property is not provided by the request. The server must create that relationship.
# The response should contain the newly-created tweet.
# IMPORTANT: when a tweet with content is created, the server must process the tweet's content for @{username} mentions and #{hashtag} tags. There is no way to create hashtags or create mentions from the API, so this must be handled automatically!
# Request:
# {
# 	"content": "{content}",
# 	"credentials": {
# 		"username": "{username}",
# 		"password": "{password}"
# 	}
# }
# Response:
# {
#   "id": {id},
#   "content": "{content}",
#   "posted": {postedDate}
#   "author": {
#     "username": "{username}",
#     "joined": {joinedDate},
#     "profile": {
#       "email": "{email}",
#       "firstName": "{firstname}",
#       "lastName": "{lastname}",
#       "phone": "{phoneNumber}"
#     }
#   }
# }
POST localhost:8080/tweets/{{secondTweetId}}/reply
Content-Type: application/json

{
  "content": "{{firstUserReply}}",
  "credentials": {
    "username": "{{firstUser}}",
    "password": "{{password}}"
  }
}

> {%
    // TODO: migrate to HTTP Client Response handler API
    // const schema = pm.environment.get('tweetSchema')
    //
    // pm.test('Schema is valid', () => {
    //     pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true
    // })
    //
    // pm.test('Tweet has id', () => {
    //     pm.expect(pm.response.json().id).to.not.eql(null)
    //     pm.environment.set('firstUserReplyId', pm.response.json().id)
    // })
    //
    // pm.test('Author is correct', () => {
    //     const author = pm.response.json().author
    //     pm.expect(author.username).to.eql(pm.environment.get('firstUser'))
    //     pm.expect(new Date(author.joined)).to.eql(new Date(pm.environment.get('firstUserJoined')))
    //     const profile = author.profile
    //     pm.expect(profile.firstName).to.eql(pm.environment.get('firstUserFirstName'))
    //     pm.expect(profile.lastName).to.eql(pm.environment.get('firstUserLastName'))
    //     pm.expect(profile.email).to.eql(pm.environment.get('firstUserEmail'))
    //     pm.expect(profile.phone).to.eql(pm.environment.get('firstUserPhone'))
    // })
    //
    // pm.test('Tweet has date posted', () => {
    //     pm.expect(pm.response.json().posted).to.not.eql(null)
    // })
    //
    // pm.test('Tweet content is correct', () => {
    //     pm.expect(pm.response.json().content).to.eql(pm.environment.get('firstUserReply'))
    // })
%}

###
# group: Tweet / Tweet Replies
# @name Get SecondTweet Replies
# Retrieves the direct replies to the tweet with the given id. if that tweet is deleted or otherwise doesn't exist, an error should be sent in lieu of a response.
# Deleted replies to the tweet should be excluded from the resonse.
# Response:
# [
#   {
#     "id": {id},
#     "content": "{context}",
#     "posted": {postedDate}
#     "author": {
#       "username": "{username}",
#       "joined": {joinedDate},
#       "profile": {
#         "email": "{email}",
#         "firstName": "{firstname}",
#         "lastName": "{lastname}",
#         "phone": "{phoneNumber}"
#       }
#     },
#   }
# ]
GET localhost:8080/tweets/{{secondTweetId}}/replies

> {%
    // TODO: migrate to HTTP Client Response handler API
    // const tweetSchema = pm.environment.get('tweetSchema')
    //
    // const schema = {
    //     type: 'array',
    //     description: 'An array of tweet dto\'s',
    //     items: { $ref: tweetSchema }
    // }
    //
    // pm.test('Status success', () => {
    //     pm.response.to.be.success
    // })
    //
    // pm.test('Schema is valid', () => {
    //   pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true
    // })
    //
    // if (pm.response.code >= 200 && pm.response.code < 300 && pm.response.json() !== null && Array.isArray(pm.response.json())) {
    //     const content = pm.response.json().map(tweet => tweet.content)
    //     const authors = pm.response.json().map(tweet => tweet.author.username)
    //     
    //     pm.test('Author is correct', () => {
    //         pm.expect(authors).to.include(pm.environment.get('firstUser'))
    //     })
    //     
    //     pm.test('Tweet content is correct', () => {
    //         pm.expect(content).to.include(pm.environment.get('firstUserReply'))
    //     })
    // }
%}

###
# group: Tweet / Repost Tweets
# @name FirstUser Retweet SecondUserTweet
# Creates a repost of the tweet with the given id. The author of the repost should match the credentials provided in the request body. If the given tweet is deleted or otherwise doesn't exist, or the given credentials do not match an active user in the database, an error should be sent in lieu of a response.
# Because this creates a repost tweet, content is not allowed. Additionally, notice that the repostOf property is not provided by the request. The server must create that relationship.
# The response should contain the newly-created tweet.
# Request:
# {
# 	"username": "{username}",
# 	"password": "{password}"
# }
# Response:
# {
#   "id": {id},
#   "content": "{content}",
#   "posted": {postedDate}
#   "author": {
#     "username": "{username}",
#     "joined": {joinedDate},
#     "profile": {
#       "email": "{email}",
#       "firstName": "{firstname}",
#       "lastName": "{lastname}",
#       "phone": "{phoneNumber}"
#     }
#   }
# }
POST localhost:8080/tweets/{{secondTweetId}}/repost
Content-Type: application/json

{
  "username": "{{firstUser}}",
  "password": "{{password}}"
}

> {%
    // TODO: migrate to HTTP Client Response handler API
    // const schema = pm.environment.get('tweetSchema')
    
    // 
    
    // pm.test('Status success', () => {
    
    //     pm.response.to.be.success
    
    // })
    
    // 
    
    // pm.test('Schema is valid', () => {
    
    //   pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true
    
    // })
    
    // 
    
    // if (pm.response.code >= 200 && pm.response.code < 300 && pm.response.json() !== null && Array.isArray(pm.response.json())) {
    
    //     const content = pm.response.json().map(tweet => tweet.content)
    
    //     const authors = pm.response.json().map(tweet => tweet.author.username)
    
    //     
    
    //     pm.test('Contains the firstUser\'s repost', () => {
    
    //         pm.expect(content).to.include(`Tweet from the second user! @${pm.environment.get('firstUser')} #${pm.environment.get('secondTag')}`)
    
    //         pm.expect(authors).to.include(pm.environment.get('firstUser'))
    
    //     })
    
    // }
%}

###
# group: Tweet / Repost Tweets
# @name Get SecondTweet Reposts
# Retrieves the direct reposts of the tweet with the given id. If that tweet is deleted or otherwise doesn't exist, an error should be sent in lieu of a response.
# Deleted reposts of the tweet should be excluded from the response.
# Response:
# [
#   {
#     "id": {id},
#     "content": "{context}",
#     "posted": {postedDate}
#     "author": {
#       "username": "{username}",
#       "joined": {joinedDate},
#       "profile": {
#         "email": "{email}",
#         "firstName": "{firstname}",
#         "lastName": "{lastname}",
#         "phone": "{phoneNumber}"
#       }
#     },
#   }
# ]
GET localhost:8080/tweets/{{secondTweetId}}/reposts

> {%
    // TODO: migrate to HTTP Client Response handler API
    // const tweetSchema = pm.environment.get('tweetSchema')
    //
    // const schema = {
    //     type: 'array',
    //     description: 'An array of tweet dto\'s',
    //     items: { $ref: tweetSchema }
    // }
    //
    // pm.test('Status success', () => {
    //     pm.response.to.be.success
    // })
    //
    // pm.test('Schema is valid', () => {
    //   pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true
    // })
    //
    // if (pm.response.code >= 200 && pm.response.code < 300 && pm.response.json() !== null && Array.isArray(pm.response.json())) {
    //     const content = pm.response.json().map(tweet => tweet.repostOf.content)
    //     const authors = pm.response.json().map(tweet => tweet.author.username)
    //     
    //     pm.test('Contains the firstUser\'s repost', () => {
    //         pm.expect(content).to.include(`Tweet from the second user! @${pm.environment.get('firstUser')} #${pm.environment.get('secondTag')}`)
    //         pm.expect(authors).to.include(pm.environment.get('firstUser'))
    //     })
    // }
%}

###
# group: Tweet / Tweet Context
# @name Get FirstUserReply Context
# Retrieves the context of the tweet with the given id. If that tweet is deleted or otherwise doesn't exist, an error should be sent in lieu of a response.
# IMPORTANT: While deleted tweets should not be included in the before and after properties of the result, transitive replies should. What that means is that if a reply to the target of the context is deleted, but there's another reply to the deleted reply, the deleted reply should be excluded but the other reply should remain.
# Response:
# {
#   "after": [{
#       "id": {id},
#       "content": "{context}",
#       "posted": {postedDate}
#       "author": {
#         "username": "{username}",
#         "joined": {joinedDate},
#         "profile": {
#           "email": "{email}",
#           "firstName": "{firstname}",
#           "lastName": "{lastname}",
#           "phone": "{phoneNumber}"
#         }
#       },
#     }
#   ],
#   "before": [
#     {
#       "id": {id},
#       "content": "{context}",
#       "posted": {postedDate}
#       "author": {
#         "username": "{username}",
#         "joined": {joinedDate},
#         "profile": {
#           "email": "{email}",
#           "firstName": "{firstname}",
#           "lastName": "{lastname}",
#           "phone": "{phoneNumber}"
#         }
#       },
#     }
#   ],
#   "target": {
#       "id": {id},
#       "content": "{context}",
#       "posted": {postedDate}
#       "author": {
#         "username": "{username}",
#         "joined": {joinedDate},
#         "profile": {
#           "email": "{email}",
#           "firstName": "{firstname}",
#           "lastName": "{lastname}",
#           "phone": "{phoneNumber}"
#         }
#       },
#     }
# }
GET localhost:8080/tweets/{{firstUserReplyId}}/context

> {%
    // TODO: migrate to HTTP Client Response handler API
    // const tweetSchema = pm.environment.get('tweetSchema')
    //
    // const schema = {
    //     type: 'object',
    //     description: 'A context dto',
    //     properties: {
    //         target: {
    //             type: 'object',
    //             $ref: tweetSchema 
    //         },
    //         before: {
    //             type: 'array',
    //             items: { $ref: tweetSchema } 
    //         },
    //         after: {
    //             type: 'array',
    //             items: { $ref: tweetSchema } 
    //         }
    //     },
    //     required: ['target', 'before', 'after'],
    // }
    //
    // pm.test('Status success', () => {
    //     pm.response.to.be.success
    // })
    //
    // pm.test('Schema is valid', () => {
    //   pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true
    // })
    //
    // const target = pm.response.json().target
    //     
    // pm.test('Target id is correct', () => {
    //     const id = target.id
    //     pm.expect(id).to.not.eql(null)
    //     pm.expect(id).to.eql(pm.environment.get('firstUserReplyId'))
    // })
    //     
    // pm.test('Target author is correct', () => {
    //     const author = target.author
    //     pm.expect(author.username).to.eql(pm.environment.get("firstUser"))
    //     pm.expect(new Date(author.joined)).to.eql(new Date(pm.environment.get("firstUserJoined")))
    //     const profile = author.profile
    //     pm.expect(profile.firstName).to.eql(pm.environment.get("firstUserFirstName"))
    //     pm.expect(profile.lastName).to.eql(pm.environment.get("firstUserLastName"))
    //     pm.expect(profile.email).to.eql(pm.environment.get("firstUserEmail"))
    //     pm.expect(profile.phone).to.eql(pm.environment.get("firstUserPhone"))
    // })
    //     
    // pm.test('Target date posted is not null', () => {
    //     pm.expect(target.posted).to.not.eql(null)
    // })
    //    
    //     
    // pm.test('Target content is correct', () => {
    //     pm.expect(target.content).to.eql(pm.environment.get('firstUserReply'))
    // })
    //
    // pm.test('Before is correct', () => {
    //     const before = pm.response.json().before
    //     pm.expect(Array.isArray(before)).to.be.true
    //     pm.expect(before.length).to.eql(1)
    //     
    //     const authors = before.map(tweet => tweet.author.username)
    //     pm.expect(authors).to.include(pm.environment.get('secondUser'))
    //     
    //     const content = before.map(tweet => tweet.content)
    //     pm.expect(content).to.include(`Tweet from the second user! @${pm.environment.get('firstUser')} #${pm.environment.get('secondTag')}`)
    // })
    //
    // pm.test('After is correct', () => {
    //     const after = pm.response.json().after
    //     pm.expect(Array.isArray(after)).to.be.true
    //     pm.expect(after.length).to.eql(0)
    // })
    //
    //
%}

###
# group: Tweet / Tweet Context
# @name Get SecondTweet Context
# Retrieves the context of the tweet with the given id. If that tweet is deleted or otherwise doesn't exist, an error should be sent in lieu of a response.
# IMPORTANT: While deleted tweets should not be included in the before and after properties of the result, transitive replies should. What that means is that if a reply to the target of the context is deleted, but there's another reply to the deleted reply, the deleted reply should be excluded but the other reply should remain.
# Response:
# {
#   "after": [{
#       "id": {id},
#       "content": "{context}",
#       "posted": {postedDate}
#       "author": {
#         "username": "{username}",
#         "joined": {joinedDate},
#         "profile": {
#           "email": "{email}",
#           "firstName": "{firstname}",
#           "lastName": "{lastname}",
#           "phone": "{phoneNumber}"
#         }
#       },
#     }
#   ],
#   "before": [
#     {
#       "id": {id},
#       "content": "{context}",
#       "posted": {postedDate}
#       "author": {
#         "username": "{username}",
#         "joined": {joinedDate},
#         "profile": {
#           "email": "{email}",
#           "firstName": "{firstname}",
#           "lastName": "{lastname}",
#           "phone": "{phoneNumber}"
#         }
#       },
#     }
#   ],
#   "target": {
#       "id": {id},
#       "content": "{context}",
#       "posted": {postedDate}
#       "author": {
#         "username": "{username}",
#         "joined": {joinedDate},
#         "profile": {
#           "email": "{email}",
#           "firstName": "{firstname}",
#           "lastName": "{lastname}",
#           "phone": "{phoneNumber}"
#         }
#       },
#     }
# }
GET localhost:8080/tweets/{{secondTweetId}}/context

> {%
    // TODO: migrate to HTTP Client Response handler API
    // const tweetSchema = pm.environment.get('tweetSchema')
    //
    // const schema = {
    //     type: 'object',
    //     description: 'A context dto',
    //     properties: {
    //         target: {
    //             type: 'object',
    //             $ref: tweetSchema 
    //         },
    //         before: {
    //             type: 'array',
    //             items: { $ref: tweetSchema } 
    //         },
    //         after: {
    //             type: 'array',
    //             items: { $ref: tweetSchema } 
    //         }
    //     },
    //     required: ['target', 'before', 'after'],
    // }
    //
    // pm.test('Status success', () => {
    //     pm.response.to.be.success
    // })
    //
    // pm.test('Schema is valid', () => {
    //   pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true
    // })
    //     
    // pm.test('Target id is correct', () => {
    //     const target = pm.response.json().target
    //     const id = target.id
    //     pm.expect(id).to.not.eql(null)
    //     pm.expect(id).to.eql(pm.environment.get('secondTweetId'))
    // })
    //     
    // pm.test('Target author is correct', () => {
    //     const target = pm.response.json().target
    //     const author = target.author
    //     pm.expect(author.username).to.eql(pm.environment.get("secondUser"))
    //     pm.expect(new Date(author.joined)).to.eql(new Date(pm.environment.get("secondUserJoined")))
    //     const profile = author.profile
    //     pm.expect(profile.firstName).to.eql(pm.environment.get("secondUserFirstName"))
    //     pm.expect(profile.lastName).to.eql(pm.environment.get("secondUserLastName"))
    //     pm.expect(profile.email).to.eql(pm.environment.get("secondUserEmail"))
    //     pm.expect(profile.phone).to.eql(pm.environment.get("secondUserPhone"))
    // })
    //     
    // pm.test('Target date posted is not null', () => {
    //     const target = pm.response.json().target
    //     pm.expect(target.posted).to.not.eql(null)
    // })
    //    
    //     
    // pm.test('Target content is correct', () => {
    //     const target = pm.response.json().target
    //     pm.expect(target.content).to.eql(`Tweet from the second user! @${pm.environment.get("firstUser")} #${pm.environment.get("secondTag")}`)
    // })
    //
    // pm.test('Before is correct', () => {
    //     const before = pm.response.json().before
    //     pm.expect(Array.isArray(before)).to.be.true
    //     pm.expect(before.length).to.eql(0)
    // })
    //
    // pm.test('After is correct', () => {
    //     const after = pm.response.json().after
    //     pm.expect(Array.isArray(after)).to.be.true
    //     pm.expect(after.length).to.eql(1)
    //     
    //     const authors = after.map(tweet => tweet.author.username)
    //     pm.expect(authors).to.include(pm.environment.get('firstUser'))
    //     
    //     const content = after.map(tweet => tweet.content)
    //     pm.expect(content).to.include(pm.environment.get('firstUserReply'))
    // })
    //
%}

###
# group: Tweet / Delete Tweet
# @name Delete RandomTweet
# "Deletes" the tweet with the given id. If no such tweet exists or the provided credentials do not match author of the tweet, an error should be sent in lieu of a response. If a tweet is successfully "deleted", the response should contain the tweet data prior to deletion.
# IMPORTANT: This action should not actually drop any records from the database! Instead, develop a way to keep track of "deleted" tweets so that even if a tweet is deleted, data with relationships to it (like replies and reposts) are still intact.
# Request:
# {
#   "username": "{username}",
#   "password": "{password}"
# }
# Response:
# {
#   "id": {id},
#   "content": "{content}",
#   "posted": {postedDate}
#   "author": {
#     "username": "{username}",
#     "joined": {joinedDate},
#     "profile": {
#       "email": "{email}",
#       "firstName": "{firstname}",
#       "lastName": "{lastname}",
#       "phone": "{phoneNumber}"
#     }
#   }
# }
DELETE localhost:8080/tweets/randomTweet
Content-Type: application/json

{
	"username": "{{firstUser}}",
	"password": "{{password}}"
}

> {%
    // TODO: migrate to HTTP Client Response handler API
    // pm.test('Status not success', () => {
    //     pm.response.to.not.be.success
    //     pm.response.to.not.be.info
    // })
    //
    // pm.test('Should not be an internal server error', () => {
    //     pm.response.to.not.be.serverError
    // })
%}

###
# group: Tweet / Delete Tweet
# @name Delete FirstTweet
# "Deletes" the tweet with the given id. If no such tweet exists or the provided credentials do not match author of the tweet, an error should be sent in lieu of a response. If a tweet is successfully "deleted", the response should contain the tweet data prior to deletion.
# IMPORTANT: This action should not actually drop any records from the database! Instead, develop a way to keep track of "deleted" tweets so that even if a tweet is deleted, data with relationships to it (like replies and reposts) are still intact.
# Request:
# {
#   "username": "{username}",
#   "password": "{password}"
# }
# Response:
# {
#   "id": {id},
#   "content": "{content}",
#   "posted": {postedDate}
#   "author": {
#     "username": "{username}",
#     "joined": {joinedDate},
#     "profile": {
#       "email": "{email}",
#       "firstName": "{firstname}",
#       "lastName": "{lastname}",
#       "phone": "{phoneNumber}"
#     }
#   }
# }
DELETE localhost:8080/tweets/{{firstTweetId}}
Content-Type: application/json

{
	"username": "{{firstUser}}",
	"password": "{{password}}"
}

> {%
    // TODO: migrate to HTTP Client Response handler API
    // const schema = pm.environment.get('tweetSchema')
    //
    // pm.test('Status success', () => {
    //     pm.response.to.be.success
    // })
    //
    // pm.test('Schema is valid', () => {
    //   pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true
    // })
    //
    // pm.test('Author should be the firstUser', () => {
    //     pm.expect(pm.response.json().author.username).to.eql(pm.environment.get('firstUser'))
    // })
    //
    // pm.test('Content should be the firstTweet', () => {
    //      pm.expect(pm.response.json().content).to.eql(`Tweet from the first user! @${pm.environment.get('secondUser')} #${pm.environment.get('firstTag')}`)
    // })
%}

###
# group: Tweet / Delete Tweet
# @name Delete SecondTweet
# "Deletes" the tweet with the given id. If no such tweet exists or the provided credentials do not match author of the tweet, an error should be sent in lieu of a response. If a tweet is successfully "deleted", the response should contain the tweet data prior to deletion.
# IMPORTANT: This action should not actually drop any records from the database! Instead, develop a way to keep track of "deleted" tweets so that even if a tweet is deleted, data with relationships to it (like replies and reposts) are still intact.
# Request:
# {
# 	"username": "{username}",
# 	"password": "{password}"
# }
# Response:
# {
#   "id": {id},
#   "content": "{content}",
#   "posted": {postedDate}
#   "author": {
#     "username": "{username}",
#     "joined": {joinedDate},
#     "profile": {
#       "email": "{email}",
#       "firstName": "{firstname}",
#       "lastName": "{lastname}",
#       "phone": "{phoneNumber}"
#     }
#   }
# }
DELETE localhost:8080/tweets/{{secondTweetId}}
Content-Type: application/json

{
    "username": "{{secondUser}}",
    "password": "{{password}}"
}

> {%
    // TODO: migrate to HTTP Client Response handler API
    // const schema = pm.environment.get('tweetSchema')
    //
    // pm.test('Status success', () => {
    //     pm.response.to.be.success
    // })
    //
    // pm.test('Schema is valid', () => {
    //   pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true
    // })
    //
    // pm.test('Author should be the secondUser', () => {
    //     pm.expect(pm.response.json().author.username).to.eql(pm.environment.get('secondUser'))
    // })
    //
    // pm.test('Content should be the secondTweet', () => {
    //      pm.expect(pm.response.json().content).to.eql(`Tweet from the second user! @${pm.environment.get('firstUser')} #${pm.environment.get('secondTag')}`)
    // })
%}

###
# group: Tweet / Delete Tweet
# @name Delete SecondTweet Again
# "Deletes" the tweet with the given id. If no such tweet exists or the provided credentials do not match author of the tweet, an error should be sent in lieu of a response. If a tweet is successfully "deleted", the response should contain the tweet data prior to deletion.
# IMPORTANT: This action should not actually drop any records from the database! Instead, develop a way to keep track of "deleted" tweets so that even if a tweet is deleted, data with relationships to it (like replies and reposts) are still intact.
# Request:
# {
#   "username": "{username}",
#   "password": "{password}"
# }
# Response:
# {
#   "id": {id},
#   "content": "{content}",
#   "posted": {postedDate}
#   "author": {
#     "username": "{username}",
#     "joined": {joinedDate},
#     "profile": {
#       "email": "{email}",
#       "firstName": "{firstname}",
#       "lastName": "{lastname}",
#       "phone": "{phoneNumber}"
#     }
#   }
# }
DELETE localhost:8080/tweets/{{secondTweetId}}
Content-Type: application/json

{
	"username": "{{secondUser}}",
	"password": "{{password}}"
}

> {%
    // TODO: migrate to HTTP Client Response handler API
    // pm.test('Status not success', () => {
    //     pm.response.to.not.be.success
    //     pm.response.to.not.be.info
    // })
    //
    // pm.test('Should not be an internal server error', () => {
    //     pm.response.to.not.be.serverError
    // })
%}

###
# group: Tweet / Delete Tweet
# @name Get SecondTweet Context After Delete
# Retrieves the context of the tweet with the given id. If that tweet is deleted or otherwise doesn't exist, an error should be sent in lieu of a response.
# IMPORTANT: While deleted tweets should not be included in the before and after properties of the result, transitive replies should. What that means is that if a reply to the target of the context is deleted, but there's another reply to the deleted reply, the deleted reply should be excluded but the other reply should remain.
# Response:
# {
#   "after": [{
#       "id": {id},
#       "content": "{context}",
#       "posted": {postedDate}
#       "author": {
#         "username": "{username}",
#         "joined": {joinedDate},
#         "profile": {
#           "email": "{email}",
#           "firstName": "{firstname}",
#           "lastName": "{lastname}",
#           "phone": "{phoneNumber}"
#         }
#       },
#     }
#   ],
#   "before": [
#     {
#       "id": {id},
#       "content": "{context}",
#       "posted": {postedDate}
#       "author": {
#         "username": "{username}",
#         "joined": {joinedDate},
#         "profile": {
#           "email": "{email}",
#           "firstName": "{firstname}",
#           "lastName": "{lastname}",
#           "phone": "{phoneNumber}"
#         }
#       },
#     }
#   ],
#   "target": {
#       "id": {id},
#       "content": "{context}",
#       "posted": {postedDate}
#       "author": {
#         "username": "{username}",
#         "joined": {joinedDate},
#         "profile": {
#           "email": "{email}",
#           "firstName": "{firstname}",
#           "lastName": "{lastname}",
#           "phone": "{phoneNumber}"
#         }
#       },
#     }
# }
GET localhost:8080/tweets/{{secondTweetId}}/context

> {%
    // TODO: migrate to HTTP Client Response handler API
    // pm.test('Status not success', () => {
    //     pm.response.to.not.be.success
    //     pm.response.to.not.be.info
    // })
    //
    // pm.test('Should not be an internal server error', () => {
    //     pm.response.to.not.be.serverError
    // })
%}

###
# group: Hashtag
# @name Get All Tags
# Retrieves all hashtags tracked by the database.
# Response:
# [
#   {
#     "firstUsed": {firstUsedDate},
#     "label": "{label}",
#     "lastUsed": {lastUsedDate}
#   }
# ]
GET localhost:8080/tags

> {%
    // TODO: migrate to HTTP Client Response handler API
    // const hashtagSchema = pm.environment.get('hashtagSchema')
    //
    // const schema = {
    //     type: 'array',
    //     description: 'An array of hashtag dto\'s',
    //     items: { $ref: hashtagSchema }
    // }
    //
    // pm.test('Status success', () => {
    //     pm.response.to.be.success
    // })
    //
    // pm.test('Schema is valid', () => {
    //   pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true
    // })
    //
    // pm.test('Should contain two values', () => {
    //     pm.expect(pm.response.json().length).to.eql(2)
    // })
    //
    // pm.test('Should contain the first and second hashtag', () => {
    //     const hashtags = pm.response.json().map(hashtag => hashtag.label)
    //     pm.expect(hashtags).to.include(pm.environment.get('firstTag'))
    //     pm.expect(hashtags).to.include(pm.environment.get('secondTag'))
    // })
%}

###
# group: Hashtag
# @name Get RandomTag
# Retrieves all (non-deleted) tweets tagged with the given hashtag label. The tweets should appear in reverse-chronological order. If no hashtag with the given label exists, an error should be sent in lieu of a response.
# A tweet is considered "tagged" by a hashtag if the tweet has content and the hashtag's label appears in that content following a #.
# Response:
# [
#   {
#     "id": {id},
#     "content": "{content}",
#     "posted": {postedDate}
#     "author": {
#       "username": "{username}",
#       "joined": {joinedDate},
#       "profile": {
#         "email": "{email}",
#         "firstName": "{firstname}",
#         "lastName": "{lastname}",
#         "phone": "{phoneNumber}"
#       }
#     }
#   }
# ]
GET localhost:8080/tags/%23mario

> {%
    // TODO: migrate to HTTP Client Response handler API
    // pm.test('Status error', () => {
    //     pm.response.to.not.be.success
    //     pm.response.to.not.be.info
    // })
    //
    // pm.test('Should not be internal server error', () => {
    //     pm.response.to.not.be.serverError
    // })
%}

###
# group: Validate / Tag Validation
# @name RandomTag Exists
# Initially the "firstTag" environment variable should not exist in the student's database.
# Expected Status: success
# Expected Response Body: false
GET localhost:8080/validate/tag/exists/randomTag

> {%
    // TODO: migrate to HTTP Client Response handler API
    // const schema = pm.environment.get('booleanSchema')
    //
    // pm.test('Status success', () => {
    //     pm.response.to.be.success
    // })
    //
    // pm.test('Schema is valid', () => {
    //     pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true
    // })
    //
    //
    // pm.test('Should return a boolean', () => {
    //     pm.expect(typeof(pm.response.json())).to.eql('boolean')
    // })
    //
    // pm.test('Should return false', () => {
    //     pm.expect(pm.response.json()).to.be.false
    // })
%}

###
# group: Validate / Tag Validation
# @name FirstTag Exists
# Now that the firstTag has been created in the firstUser's tweet, we need to verify it exists. Should return true and a success status.
# Expected Status: success
# Expected Response Body: true
GET localhost:8080/validate/tag/exists/{{firstTag}}

> {%
    // TODO: migrate to HTTP Client Response handler API
    // const schema = pm.environment.get('booleanSchema')
    //
    // pm.test('Status success', () => {
    //     pm.response.to.have.success
    // })
    //
    // pm.test('Schema is valid', () => {
    //     pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true
    // })
    //
    // pm.test('FirstTag should exist', () => {
    //     pm.expect(pm.response.json()).to.be.true
    // })
%}

###
# group: Validate / Tag Validation
# @name SecondTag Exists
# Now that the secondTag has been created in the secondUser's tweet, we need to verify it exists. Should return true and a success status.
# Expected Status: success
# Expected Response Body: true
GET localhost:8080/validate/tag/exists/{{secondTag}}

> {%
    // TODO: migrate to HTTP Client Response handler API
    // const schema = pm.environment.get('booleanSchema')
    //
    // pm.test('Status success', () => {
    //     pm.response.to.have.success
    // })
    //
    // pm.test('Schema is valid', () => {
    //     pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true
    // })
    //
    // pm.test('SecondTag should exist', () => {
    //     pm.expect(pm.response.json()).to.be.true
    // })
%}

###
# group: Validate / User Validation
# @name RandomUser Available
# Validates that the /username/available/@{username} endpoint is in the correct format.
GET localhost:8080/validate/username/available/@randomUser

> {%
    // TODO: migrate to HTTP Client Response handler API
    // const schema = pm.environment.get('booleanSchema')
    //
    // pm.test('Status success', () => {
    //     pm.response.to.be.success
    // })
    //
    // pm.test('Schema is valid', () => {
    //     pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true
    // })
    //
    //
    // pm.test('Should return a boolean', () => {
    //     pm.expect(typeof(pm.response.json())).to.eql('boolean')
    // })
    //
    // pm.test('Should return true', () => {
    //     pm.expect(pm.response.json()).to.be.true
    // })
%}

###
# group: Validate / User Validation
# @name RandomUser Exists
# Validates that the /username/exists/@{username} endpoint is in the correct format.
GET localhost:8080/validate/username/exists/@randomUser
Content-Type: application/json

> {%
    // TODO: migrate to HTTP Client Response handler API
    // const schema = pm.environment.get('booleanSchema')
    //
    // pm.test('Status success', () => {
    //     pm.response.to.be.success
    // })
    //
    // pm.test('Schema is valid', () => {
    //     pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true
    // })
    //
    //
    // pm.test('Should return a boolean', () => {
    //     pm.expect(typeof(pm.response.json())).to.eql('boolean')
    // })
    //
    // pm.test('Should return false', () => {
    //     pm.expect(pm.response.json()).to.be.false
    // })
%}

###
@firstUser = therealmc
# group: Validate / User Validation
# @name FirstUser Available After Creation
# Validates that the /username/available/@{username} endpoint is in the correct format.
GET localhost:8080/validate/username/available/@{{firstUser}}

> {%
    // TODO: migrate to HTTP Client Response handler API
    // const schema = pm.environment.get('booleanSchema')
    //
    // pm.test('Status success', () => {
    //     pm.response.to.be.success
    // })
    //
    // pm.test('Schema is valid', () => {
    //     pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true
    // })
    //
    // pm.test('Should return a boolean', () => {
    //     pm.expect(typeof(pm.response.json())).to.eql('boolean')
    // })
    //
    // pm.test('FirstUser should not be available', () => {
    //     pm.expect(pm.response.json()).to.be.false
    // })
%}

###
# group: Validate / User Validation
# @name FirstUser Exists After Creation
# Validates that the /username/available/@{username} endpoint is in the correct format.
GET localhost:8080/validate/username/exists/@{{firstUser}}

> {%
    // TODO: migrate to HTTP Client Response handler API
    // const schema = pm.environment.get('booleanSchema')
    //
    // pm.test('Status success', () => {
    //     pm.response.to.be.success
    // })
    //
    // pm.test('Schema is valid', () => {
    //     pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true
    // })
    //
    // pm.test('Should return a boolean', () => {
    //     pm.expect(typeof(pm.response.json())).to.eql('boolean')
    // })
    //
    // pm.test('FirstUser should exist', () => {
    //     pm.expect(pm.response.json()).to.be.true
    // })
%}

###
@secondUser = therealmc
# group: Validate / User Validation
# @name SecondUser Available After Creation
# Validates that the /username/available/@{username} endpoint is in the correct format.
GET localhost:8080/validate/username/available/@{{secondUser}}

> {%
    // TODO: migrate to HTTP Client Response handler API
    // const schema = pm.environment.get('booleanSchema')
    //
    // pm.test('Status success', () => {
    //     pm.response.to.be.success
    // })
    //
    // pm.test('Schema is valid', () => {
    //     pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true
    // })
    //
    // pm.test('Should return a boolean', () => {
    //     pm.expect(typeof(pm.response.json())).to.eql('boolean')
    // })
    //
    // pm.test('SecondUser should not be available', () => {
    //     pm.expect(pm.response.json()).to.be.false
    // })
%}

###
# group: Validate / User Validation
# @name SecondUser Exists After Creation
# Validates that the /username/available/@{username} endpoint is in the correct format.
GET localhost:8080/validate/username/exists/@{{secondUser}}

> {%
    // TODO: migrate to HTTP Client Response handler API
    // const schema = pm.environment.get('booleanSchema')
    //
    // pm.test('Status success', () => {
    //     pm.response.to.be.success
    // })
    //
    // pm.test('Schema is valid', () => {
    //     pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true
    // })
    //
    // pm.test('Should return a boolean', () => {
    //     pm.expect(typeof(pm.response.json())).to.eql('boolean')
    // })
    //
    // pm.test('SecondUser should exist', () => {
    //     pm.expect(pm.response.json()).to.be.true
    // })
%}

###
# group: Cleanup
# @name FirstUser Unfollow SecondUser
# Attempts to unfollow the firstUser without providing the username of the secondUser. Should return an error status and no body.
# Expected Status: error
# Expected Body: none
POST localhost:8080/users/@{{secondUser}}/unfollow
Content-Type: application/json

{
  	"username": "{{firstUser}}",
  	"password": "{{password}}"
}

> {%
    // TODO: migrate to HTTP Client Response handler API
    // pm.test('Should be success', () => {
    //     pm.response.to.be.success
    // })
%}

###
# group: Cleanup
# @name SecondUser Unfollow FirstUser
# Attempts to unfollow the firstUser without providing the username of the secondUser. Should return an error status and no body.
# Expected Status: error
# Expected Body: none
POST localhost:8080/users/@{{firstUser}}/unfollow
Content-Type: application/json

{
  	"username": "{{secondUser}}",
  	"password": "{{password}}"
}

> {%
    // TODO: migrate to HTTP Client Response handler API
    // pm.test('Should be success', () => {
    //     pm.response.to.be.success
    // })
%}

###
# group: Cleanup
# @name Delete FirstUser
# "Deletes" a user with the given username. If no such user exists or the provided credentials do not match the user, an error should be sent in lieu of a response. If a user is successfully "deleted", the response should contain the user data prior to deletion.
# **IMPORTANT**: This action should not actually drop any records from the database! Instead, develop a way to keep track of "deleted" users so that if a user is re-activated, all of their tweets and information are restored.
# #### Request
# ```
# {
# 	"credentials": {
# 		"username": "string",
# 		"password": "string"
# 	}
# }
# ```
# #### Response
# ```
# { // User
# 	"username": "string",
# 	"profile": {
# 		"firstName"?: "string",
# 		"lastName"?: "string",
# 		"email": "string",
# 		"phone"?: "string"
# 	},
# 	"joined": timestamp
# }
# ```
# * Remember that question marks denote optional values.
DELETE localhost:8080/users/@{{firstUser}}
Content-Type: application/json

{
    "username": "{{firstUser}}",
    "password": "{{password}}"
}

> {%
    // TODO: migrate to HTTP Client Response handler API
    // const schema = pm.environment.get('userSchema')
    //
    //
    // pm.test('Success status', () => {
    //     pm.response.to.be.success
    // })
    //
    // pm.test('Schema is valid', () => {
    //   pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true
    // })
    //
    // pm.test('Username is correct', () => {
    //     pm.expect(pm.response.json().username).to.eql(pm.environment.get('firstUser'))
    // })
    //
    // pm.test('Joined has not been modified', () => {
    //     pm.expect(new Date(pm.response.json().joined)).to.eql(new Date(pm.environment.get('firstUserJoined')))
    // })
    //
    // pm.test('Profile is correct', () => {
    //     const profile = pm.response.json().profile
    //     pm.expect(profile.firstName).to.eql(pm.environment.get('firstUserFirstName'))
    //     pm.expect(profile.lastName).to.eql(pm.environment.get('firstUserLastName'))
    //     pm.expect(profile.email).to.eql(pm.environment.get('firstUserEmail'))
    //     pm.expect(profile.phone).to.eql(pm.environment.get('firstUserPhone'))
    // })
%}

###
# group: Cleanup
# @name Delete SecondUser
# "Deletes" a user with the given username. If no such user exists or the provided credentials do not match the user, an error should be sent in lieu of a response. If a user is successfully "deleted", the response should contain the user data prior to deletion.
# **IMPORTANT**: This action should not actually drop any records from the database! Instead, develop a way to keep track of "deleted" users so that if a user is re-activated, all of their tweets and information are restored.
# #### Request
# ```
# {
# 	"credentials": {
# 		"username": "string",
# 		"password": "string"
# 	}
# }
# ```
# #### Response
# ```
# { // User
# 	"username": "string",
# 	"profile": {
# 		"firstName"?: "string",
# 		"lastName"?: "string",
# 		"email": "string",
# 		"phone"?: "string"
# 	},
# 	"joined": timestamp
# }
# ```
# * Remember that question marks denote optional values.
DELETE localhost:8080/users/@{{secondUser}}
Content-Type: application/json

{
    "username": "{{secondUser}}",
    "password": "{{password}}"
}

> {%
    // TODO: migrate to HTTP Client Response handler API
    // const schema = pm.environment.get('userSchema')
    //
    //
    // pm.test('Success status', () => {
    //     pm.response.to.be.success
    // })
    //
    // pm.test('Schema is valid', () => {
    //   pm.expect(tv4.validate(pm.response.json(), schema)).to.be.true
    // })
    //
    // pm.test('Username is correct', () => {
    //     pm.expect(pm.response.json().username).to.eql(pm.environment.get('secondUser'))
    // })
    //
    // pm.test('Joined has not been modified', () => {
    //     pm.expect(new Date(pm.response.json().joined)).to.eql(new Date(pm.environment.get('secondUserJoined')))
    // })
    //
    // pm.test('Profile is correct', () => {
    //     const profile = pm.response.json().profile
    //     pm.expect(profile.firstName).to.eql(pm.environment.get('secondUserFirstName'))
    //     pm.expect(profile.lastName).to.eql(pm.environment.get('secondUserLastName'))
    //     pm.expect(profile.email).to.eql(pm.environment.get('secondUserEmail'))
    //     pm.expect(profile.phone).to.eql(pm.environment.get('secondUserPhone'))
    // })
%}